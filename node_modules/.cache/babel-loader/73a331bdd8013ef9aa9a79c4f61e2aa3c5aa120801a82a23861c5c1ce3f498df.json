{"ast":null,"code":"import { ParticlesInteractorBase, getRandom } from \"@tsparticles/engine\";\nconst minStagesCount = 1,\n  double = 2;\nexport class ParticlesInfecter extends ParticlesInteractorBase {\n  constructor(container) {\n    super(container);\n  }\n  clear() {}\n  init() {}\n  interact(p1, delta) {\n    const infecter = this.container.infecter;\n    if (!infecter) {\n      return;\n    }\n    infecter.updateInfection(p1, delta.value);\n    if (p1.infection?.stage === undefined) {\n      return;\n    }\n    const container = this.container,\n      options = container.actualOptions,\n      infectionOptions = options.infection;\n    if (!infectionOptions?.enable || infectionOptions.stages.length < minStagesCount) {\n      return;\n    }\n    const infectionStage1 = infectionOptions.stages[p1.infection.stage],\n      pxRatio = container.retina.pixelRatio,\n      radius = p1.getRadius() * double + infectionStage1.radius * pxRatio,\n      pos = p1.getPosition(),\n      infectedStage1 = infectionStage1.infectedStage ?? p1.infection.stage,\n      query = container.particles.quadTree.queryCircle(pos, radius),\n      infections = infectionStage1.rate,\n      neighbors = query.length;\n    for (const p2 of query) {\n      const infP2 = p2;\n      if (infP2 === p1 || infP2.destroyed || infP2.spawning || !(infP2.infection?.stage === undefined || infP2.infection.stage !== p1.infection.stage) || getRandom() >= infections / neighbors) {\n        continue;\n      }\n      if (infP2.infection?.stage === undefined) {\n        infecter.startInfection(infP2, infectedStage1);\n      } else if (infP2.infection.stage < p1.infection.stage) {\n        infecter.updateInfectionStage(infP2, infectedStage1);\n      } else if (infP2.infection.stage > p1.infection.stage) {\n        const infectionStage2 = infectionOptions.stages[infP2.infection.stage];\n        const infectedStage2 = infectionStage2?.infectedStage ?? infP2.infection.stage;\n        infecter.updateInfectionStage(p1, infectedStage2);\n      }\n    }\n  }\n  isEnabled() {\n    return this.container.actualOptions?.infection?.enable ?? false;\n  }\n  reset() {}\n}","map":{"version":3,"names":["ParticlesInteractorBase","getRandom","minStagesCount","double","ParticlesInfecter","constructor","container","clear","init","interact","p1","delta","infecter","updateInfection","value","infection","stage","undefined","options","actualOptions","infectionOptions","enable","stages","length","infectionStage1","pxRatio","retina","pixelRatio","radius","getRadius","pos","getPosition","infectedStage1","infectedStage","query","particles","quadTree","queryCircle","infections","rate","neighbors","p2","infP2","destroyed","spawning","startInfection","updateInfectionStage","infectionStage2","infectedStage2","isEnabled","reset"],"sources":["/Users/nyanaung/repos/portfolio/node_modules/@tsparticles/plugin-infection/browser/ParticlesInfecter.js"],"sourcesContent":["import { ParticlesInteractorBase, getRandom } from \"@tsparticles/engine\";\nconst minStagesCount = 1, double = 2;\nexport class ParticlesInfecter extends ParticlesInteractorBase {\n    constructor(container) {\n        super(container);\n    }\n    clear() {\n    }\n    init() {\n    }\n    interact(p1, delta) {\n        const infecter = this.container.infecter;\n        if (!infecter) {\n            return;\n        }\n        infecter.updateInfection(p1, delta.value);\n        if (p1.infection?.stage === undefined) {\n            return;\n        }\n        const container = this.container, options = container.actualOptions, infectionOptions = options.infection;\n        if (!infectionOptions?.enable || infectionOptions.stages.length < minStagesCount) {\n            return;\n        }\n        const infectionStage1 = infectionOptions.stages[p1.infection.stage], pxRatio = container.retina.pixelRatio, radius = p1.getRadius() * double + infectionStage1.radius * pxRatio, pos = p1.getPosition(), infectedStage1 = infectionStage1.infectedStage ?? p1.infection.stage, query = container.particles.quadTree.queryCircle(pos, radius), infections = infectionStage1.rate, neighbors = query.length;\n        for (const p2 of query) {\n            const infP2 = p2;\n            if (infP2 === p1 ||\n                infP2.destroyed ||\n                infP2.spawning ||\n                !(infP2.infection?.stage === undefined || infP2.infection.stage !== p1.infection.stage) ||\n                getRandom() >= infections / neighbors) {\n                continue;\n            }\n            if (infP2.infection?.stage === undefined) {\n                infecter.startInfection(infP2, infectedStage1);\n            }\n            else if (infP2.infection.stage < p1.infection.stage) {\n                infecter.updateInfectionStage(infP2, infectedStage1);\n            }\n            else if (infP2.infection.stage > p1.infection.stage) {\n                const infectionStage2 = infectionOptions.stages[infP2.infection.stage];\n                const infectedStage2 = infectionStage2?.infectedStage ?? infP2.infection.stage;\n                infecter.updateInfectionStage(p1, infectedStage2);\n            }\n        }\n    }\n    isEnabled() {\n        return this.container.actualOptions?.infection?.enable ?? false;\n    }\n    reset() {\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}