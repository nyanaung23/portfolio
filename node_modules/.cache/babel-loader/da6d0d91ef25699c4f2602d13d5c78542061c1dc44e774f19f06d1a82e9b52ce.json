{"ast":null,"code":"import { getDistance, getRandom } from \"@tsparticles/engine\";\nconst double = 2,\n  doublePI = Math.PI * double;\nexport class PoissonDisc {\n  constructor(size, radius, retries, dimensions, firstPoint) {\n    this.size = {\n      ...size\n    };\n    this.radius = radius;\n    this.retries = retries;\n    this.dimensions = dimensions;\n    this.cellSize = Math.floor(this.radius / Math.sqrt(this.dimensions));\n    this.cols = Math.floor(this.size.width / this.cellSize);\n    this.rows = Math.floor(this.size.height / this.cellSize);\n    this.points = [];\n    this.active = [];\n    this.grid = [];\n    this.firstPoint = firstPoint ? {\n      ...firstPoint\n    } : undefined;\n    this.reset();\n  }\n  addPoint(inputPoint) {\n    const point = {\n        position: {\n          ...inputPoint\n        },\n        gridPosition: {\n          x: Math.floor(inputPoint.x / this.cellSize),\n          y: Math.floor(inputPoint.y / this.cellSize)\n        }\n      },\n      pointIndex = this.points.length;\n    this.points.push(point);\n    this.grid[point.gridPosition.y][point.gridPosition.x] = pointIndex;\n    this.active.push(pointIndex);\n  }\n  getRandom(min, max) {\n    return Math.floor(getRandom() * (max - min)) + min;\n  }\n  initialiseGrid() {\n    for (let y = 0; y <= this.rows; y++) {\n      this.grid[y] = [];\n      for (let x = 0; x <= this.cols; x++) {\n        this.grid[y][x] = -1;\n      }\n    }\n  }\n  reset() {\n    this.points = [];\n    this.active = [];\n    this.grid = [];\n    this.initialiseGrid();\n    if (this.firstPoint) {\n      this.addPoint(this.firstPoint);\n    } else {\n      const minCoordinate = 0;\n      this.addPoint({\n        x: this.getRandom(minCoordinate, this.size.width),\n        y: this.getRandom(minCoordinate, this.size.height)\n      });\n    }\n  }\n  async run() {\n    this.reset();\n    const minCount = 0,\n      step = 1;\n    while (this.active.length > minCount) {\n      await this.steps(step);\n    }\n  }\n  async steps(steps) {\n    const minCount = 0;\n    for (let i = 0; i < steps; i++) {\n      if (this.active.length <= minCount) {\n        continue;\n      }\n      await this._step();\n    }\n  }\n  _getNewPoint(currentPoint, tries) {\n    const minCoordinate = 0,\n      gridMinValue = 0,\n      maxNeighbourIndex = 1,\n      newAngle = tries * (doublePI / this.retries),\n      newDist = this.getRandom(this.radius, this.radius * double),\n      offset = {\n        x: Math.cos(newAngle) * newDist,\n        y: Math.sin(newAngle) * newDist\n      },\n      newPoint = {\n        x: Math.floor(currentPoint.position.x + offset.x),\n        y: Math.floor(currentPoint.position.y + offset.y)\n      },\n      newGridCoords = {\n        x: Math.floor(newPoint.x / this.cellSize),\n        y: Math.floor(newPoint.y / this.cellSize)\n      };\n    if (newPoint.x > minCoordinate && newPoint.x < this.size.width && newPoint.y > minCoordinate && newPoint.y < this.size.height) {\n      if (this.grid[newGridCoords.y][newGridCoords.x] < gridMinValue) {\n        for (let i = -1; i <= maxNeighbourIndex; i++) {\n          for (let j = -1; j <= maxNeighbourIndex; j++) {\n            const neighbourGrid = {\n              x: newGridCoords.x + j,\n              y: newGridCoords.y + i\n            };\n            if (neighbourGrid.x >= minCoordinate && neighbourGrid.y >= minCoordinate && neighbourGrid.x < this.cols && neighbourGrid.y < this.rows && (neighbourGrid.x !== newGridCoords.x || neighbourGrid.y !== newGridCoords.y)) {\n              if (this.grid[neighbourGrid.y][neighbourGrid.x] >= gridMinValue) {\n                const neighbourIndex = this.grid[neighbourGrid.y][neighbourGrid.x],\n                  neighbour = this.points[neighbourIndex],\n                  dist = getDistance(newPoint, neighbour.position);\n                if (dist < this.radius) {\n                  return;\n                }\n              }\n            }\n          }\n        }\n      } else {\n        return;\n      }\n    } else {\n      return;\n    }\n    return newPoint;\n  }\n  async _step() {\n    const minCount = 0,\n      randomActive = this.getRandom(minCount, this.active.length);\n    return new Promise(resolve => {\n      let foundNewPoint = false;\n      for (let tries = 0; tries < this.retries; tries++) {\n        const newPoint = this._getNewPoint(this.points[this.active[randomActive]], tries);\n        if (newPoint) {\n          foundNewPoint = true;\n          this.addPoint(newPoint);\n          break;\n        }\n      }\n      if (!foundNewPoint) {\n        const deleteCount = 1;\n        this.active.splice(randomActive, deleteCount);\n      }\n      resolve();\n    });\n  }\n}","map":{"version":3,"names":["getDistance","getRandom","double","doublePI","Math","PI","PoissonDisc","constructor","size","radius","retries","dimensions","firstPoint","cellSize","floor","sqrt","cols","width","rows","height","points","active","grid","undefined","reset","addPoint","inputPoint","point","position","gridPosition","x","y","pointIndex","length","push","min","max","initialiseGrid","minCoordinate","run","minCount","step","steps","i","_step","_getNewPoint","currentPoint","tries","gridMinValue","maxNeighbourIndex","newAngle","newDist","offset","cos","sin","newPoint","newGridCoords","j","neighbourGrid","neighbourIndex","neighbour","dist","randomActive","Promise","resolve","foundNewPoint","deleteCount","splice"],"sources":["/Users/nyanaung/repos/portfolio/node_modules/@tsparticles/plugin-poisson-disc/browser/PoissonDisc.js"],"sourcesContent":["import { getDistance, getRandom } from \"@tsparticles/engine\";\nconst double = 2, doublePI = Math.PI * double;\nexport class PoissonDisc {\n    constructor(size, radius, retries, dimensions, firstPoint) {\n        this.size = { ...size };\n        this.radius = radius;\n        this.retries = retries;\n        this.dimensions = dimensions;\n        this.cellSize = Math.floor(this.radius / Math.sqrt(this.dimensions));\n        this.cols = Math.floor(this.size.width / this.cellSize);\n        this.rows = Math.floor(this.size.height / this.cellSize);\n        this.points = [];\n        this.active = [];\n        this.grid = [];\n        this.firstPoint = firstPoint ? { ...firstPoint } : undefined;\n        this.reset();\n    }\n    addPoint(inputPoint) {\n        const point = {\n            position: { ...inputPoint },\n            gridPosition: {\n                x: Math.floor(inputPoint.x / this.cellSize),\n                y: Math.floor(inputPoint.y / this.cellSize),\n            },\n        }, pointIndex = this.points.length;\n        this.points.push(point);\n        this.grid[point.gridPosition.y][point.gridPosition.x] = pointIndex;\n        this.active.push(pointIndex);\n    }\n    getRandom(min, max) {\n        return Math.floor(getRandom() * (max - min)) + min;\n    }\n    initialiseGrid() {\n        for (let y = 0; y <= this.rows; y++) {\n            this.grid[y] = [];\n            for (let x = 0; x <= this.cols; x++) {\n                this.grid[y][x] = -1;\n            }\n        }\n    }\n    reset() {\n        this.points = [];\n        this.active = [];\n        this.grid = [];\n        this.initialiseGrid();\n        if (this.firstPoint) {\n            this.addPoint(this.firstPoint);\n        }\n        else {\n            const minCoordinate = 0;\n            this.addPoint({\n                x: this.getRandom(minCoordinate, this.size.width),\n                y: this.getRandom(minCoordinate, this.size.height),\n            });\n        }\n    }\n    async run() {\n        this.reset();\n        const minCount = 0, step = 1;\n        while (this.active.length > minCount) {\n            await this.steps(step);\n        }\n    }\n    async steps(steps) {\n        const minCount = 0;\n        for (let i = 0; i < steps; i++) {\n            if (this.active.length <= minCount) {\n                continue;\n            }\n            await this._step();\n        }\n    }\n    _getNewPoint(currentPoint, tries) {\n        const minCoordinate = 0, gridMinValue = 0, maxNeighbourIndex = 1, newAngle = tries * (doublePI / this.retries), newDist = this.getRandom(this.radius, this.radius * double), offset = {\n            x: Math.cos(newAngle) * newDist,\n            y: Math.sin(newAngle) * newDist,\n        }, newPoint = {\n            x: Math.floor(currentPoint.position.x + offset.x),\n            y: Math.floor(currentPoint.position.y + offset.y),\n        }, newGridCoords = {\n            x: Math.floor(newPoint.x / this.cellSize),\n            y: Math.floor(newPoint.y / this.cellSize),\n        };\n        if (newPoint.x > minCoordinate &&\n            newPoint.x < this.size.width &&\n            newPoint.y > minCoordinate &&\n            newPoint.y < this.size.height) {\n            if (this.grid[newGridCoords.y][newGridCoords.x] < gridMinValue) {\n                for (let i = -1; i <= maxNeighbourIndex; i++) {\n                    for (let j = -1; j <= maxNeighbourIndex; j++) {\n                        const neighbourGrid = {\n                            x: newGridCoords.x + j,\n                            y: newGridCoords.y + i,\n                        };\n                        if (neighbourGrid.x >= minCoordinate &&\n                            neighbourGrid.y >= minCoordinate &&\n                            neighbourGrid.x < this.cols &&\n                            neighbourGrid.y < this.rows &&\n                            (neighbourGrid.x !== newGridCoords.x || neighbourGrid.y !== newGridCoords.y)) {\n                            if (this.grid[neighbourGrid.y][neighbourGrid.x] >= gridMinValue) {\n                                const neighbourIndex = this.grid[neighbourGrid.y][neighbourGrid.x], neighbour = this.points[neighbourIndex], dist = getDistance(newPoint, neighbour.position);\n                                if (dist < this.radius) {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                return;\n            }\n        }\n        else {\n            return;\n        }\n        return newPoint;\n    }\n    async _step() {\n        const minCount = 0, randomActive = this.getRandom(minCount, this.active.length);\n        return new Promise(resolve => {\n            let foundNewPoint = false;\n            for (let tries = 0; tries < this.retries; tries++) {\n                const newPoint = this._getNewPoint(this.points[this.active[randomActive]], tries);\n                if (newPoint) {\n                    foundNewPoint = true;\n                    this.addPoint(newPoint);\n                    break;\n                }\n            }\n            if (!foundNewPoint) {\n                const deleteCount = 1;\n                this.active.splice(randomActive, deleteCount);\n            }\n            resolve();\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}