{"ast":null,"code":"import { millisecondsToSeconds } from \"@tsparticles/engine\";\nconst videoTypes = [\"webm\", \"ogg\", \"mp4\", \"x-matroska\"],\n  codecs = [\"vp9\", \"vp9.0\", \"vp8\", \"vp8.0\", \"avc1\", \"av1\", \"h265\", \"h.265\", \"h264\", \"h.264\", \"opus\", \"pcm\", \"aac\", \"mpeg\", \"mp4a\"];\nfunction getVideoSupportedMimeTypes() {\n  const isSupported = type => MediaRecorder.isTypeSupported(type),\n    supported = [];\n  videoTypes.forEach(type => {\n    const mimeType = `video/${type}`;\n    codecs.forEach(codec => [`${mimeType};codecs=${codec}`, `${mimeType};codecs=${codec.toUpperCase()}`].forEach(variation => {\n      if (isSupported(variation)) {\n        supported.push(variation);\n      }\n    }));\n    if (isSupported(mimeType)) {\n      supported.push(mimeType);\n    }\n  });\n  return supported;\n}\nexport class ExportVideoInstance {\n  constructor(container, engine) {\n    this._supportedTypes = [];\n    this._exportVideo = async data => {\n      const element = this._container.canvas.element;\n      if (!element) {\n        return;\n      }\n      return new Promise(resolve => {\n        const stream = element.captureStream(data.fps ?? this._container.actualOptions.fpsLimit),\n          firstIndex = 0,\n          mimeType = data.mimeType ?? this._supportedTypes[firstIndex],\n          recorder = new MediaRecorder(stream, {\n            mimeType\n          }),\n          chunks = [],\n          defaultDuration = 5;\n        recorder.addEventListener(\"dataavailable\", event => {\n          chunks.push(event.data);\n        });\n        recorder.addEventListener(\"stop\", () => {\n          resolve(new Blob(chunks, {\n            type: mimeType\n          }));\n        });\n        recorder.start();\n        setTimeout(() => {\n          recorder.stop();\n        }, data.duration ?? defaultDuration * millisecondsToSeconds);\n      });\n    };\n    this._container = container;\n    this._engine = engine;\n    this._supportedTypes = getVideoSupportedMimeTypes();\n  }\n  async export(type, data) {\n    const res = {\n      supported: false\n    };\n    switch (type) {\n      case \"video\":\n        res.supported = true;\n        res.blob = await this._exportVideo(data);\n        break;\n    }\n    return res;\n  }\n}","map":{"version":3,"names":["millisecondsToSeconds","videoTypes","codecs","getVideoSupportedMimeTypes","isSupported","type","MediaRecorder","isTypeSupported","supported","forEach","mimeType","codec","toUpperCase","variation","push","ExportVideoInstance","constructor","container","engine","_supportedTypes","_exportVideo","data","element","_container","canvas","Promise","resolve","stream","captureStream","fps","actualOptions","fpsLimit","firstIndex","recorder","chunks","defaultDuration","addEventListener","event","Blob","start","setTimeout","stop","duration","_engine","export","res","blob"],"sources":["/Users/nyanaung/repos/portfolio/node_modules/@tsparticles/plugin-export-video/browser/ExportVideoInstance.js"],"sourcesContent":["import { millisecondsToSeconds, } from \"@tsparticles/engine\";\nconst videoTypes = [\"webm\", \"ogg\", \"mp4\", \"x-matroska\"], codecs = [\n    \"vp9\",\n    \"vp9.0\",\n    \"vp8\",\n    \"vp8.0\",\n    \"avc1\",\n    \"av1\",\n    \"h265\",\n    \"h.265\",\n    \"h264\",\n    \"h.264\",\n    \"opus\",\n    \"pcm\",\n    \"aac\",\n    \"mpeg\",\n    \"mp4a\",\n];\nfunction getVideoSupportedMimeTypes() {\n    const isSupported = (type) => MediaRecorder.isTypeSupported(type), supported = [];\n    videoTypes.forEach(type => {\n        const mimeType = `video/${type}`;\n        codecs.forEach(codec => [\n            `${mimeType};codecs=${codec}`,\n            `${mimeType};codecs=${codec.toUpperCase()}`,\n        ].forEach(variation => {\n            if (isSupported(variation)) {\n                supported.push(variation);\n            }\n        }));\n        if (isSupported(mimeType)) {\n            supported.push(mimeType);\n        }\n    });\n    return supported;\n}\nexport class ExportVideoInstance {\n    constructor(container, engine) {\n        this._supportedTypes = [];\n        this._exportVideo = async (data) => {\n            const element = this._container.canvas.element;\n            if (!element) {\n                return;\n            }\n            return new Promise(resolve => {\n                const stream = element.captureStream(data.fps ?? this._container.actualOptions.fpsLimit), firstIndex = 0, mimeType = data.mimeType ?? this._supportedTypes[firstIndex], recorder = new MediaRecorder(stream, {\n                    mimeType,\n                }), chunks = [], defaultDuration = 5;\n                recorder.addEventListener(\"dataavailable\", (event) => {\n                    chunks.push(event.data);\n                });\n                recorder.addEventListener(\"stop\", () => {\n                    resolve(new Blob(chunks, { type: mimeType }));\n                });\n                recorder.start();\n                setTimeout(() => {\n                    recorder.stop();\n                }, data.duration ?? defaultDuration * millisecondsToSeconds);\n            });\n        };\n        this._container = container;\n        this._engine = engine;\n        this._supportedTypes = getVideoSupportedMimeTypes();\n    }\n    async export(type, data) {\n        const res = {\n            supported: false,\n        };\n        switch (type) {\n            case \"video\":\n                res.supported = true;\n                res.blob = await this._exportVideo(data);\n                break;\n        }\n        return res;\n    }\n}\n"],"mappings":"AAAA,SAASA,qBAAqB,QAAS,qBAAqB;AAC5D,MAAMC,UAAU,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,YAAY,CAAC;EAAEC,MAAM,GAAG,CAC9D,KAAK,EACL,OAAO,EACP,KAAK,EACL,OAAO,EACP,MAAM,EACN,KAAK,EACL,MAAM,EACN,OAAO,EACP,MAAM,EACN,OAAO,EACP,MAAM,EACN,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,CACT;AACD,SAASC,0BAA0BA,CAAA,EAAG;EAClC,MAAMC,WAAW,GAAIC,IAAI,IAAKC,aAAa,CAACC,eAAe,CAACF,IAAI,CAAC;IAAEG,SAAS,GAAG,EAAE;EACjFP,UAAU,CAACQ,OAAO,CAACJ,IAAI,IAAI;IACvB,MAAMK,QAAQ,GAAG,SAASL,IAAI,EAAE;IAChCH,MAAM,CAACO,OAAO,CAACE,KAAK,IAAI,CACpB,GAAGD,QAAQ,WAAWC,KAAK,EAAE,EAC7B,GAAGD,QAAQ,WAAWC,KAAK,CAACC,WAAW,CAAC,CAAC,EAAE,CAC9C,CAACH,OAAO,CAACI,SAAS,IAAI;MACnB,IAAIT,WAAW,CAACS,SAAS,CAAC,EAAE;QACxBL,SAAS,CAACM,IAAI,CAACD,SAAS,CAAC;MAC7B;IACJ,CAAC,CAAC,CAAC;IACH,IAAIT,WAAW,CAACM,QAAQ,CAAC,EAAE;MACvBF,SAAS,CAACM,IAAI,CAACJ,QAAQ,CAAC;IAC5B;EACJ,CAAC,CAAC;EACF,OAAOF,SAAS;AACpB;AACA,OAAO,MAAMO,mBAAmB,CAAC;EAC7BC,WAAWA,CAACC,SAAS,EAAEC,MAAM,EAAE;IAC3B,IAAI,CAACC,eAAe,GAAG,EAAE;IACzB,IAAI,CAACC,YAAY,GAAG,MAAOC,IAAI,IAAK;MAChC,MAAMC,OAAO,GAAG,IAAI,CAACC,UAAU,CAACC,MAAM,CAACF,OAAO;MAC9C,IAAI,CAACA,OAAO,EAAE;QACV;MACJ;MACA,OAAO,IAAIG,OAAO,CAACC,OAAO,IAAI;QAC1B,MAAMC,MAAM,GAAGL,OAAO,CAACM,aAAa,CAACP,IAAI,CAACQ,GAAG,IAAI,IAAI,CAACN,UAAU,CAACO,aAAa,CAACC,QAAQ,CAAC;UAAEC,UAAU,GAAG,CAAC;UAAEtB,QAAQ,GAAGW,IAAI,CAACX,QAAQ,IAAI,IAAI,CAACS,eAAe,CAACa,UAAU,CAAC;UAAEC,QAAQ,GAAG,IAAI3B,aAAa,CAACqB,MAAM,EAAE;YACzMjB;UACJ,CAAC,CAAC;UAAEwB,MAAM,GAAG,EAAE;UAAEC,eAAe,GAAG,CAAC;QACpCF,QAAQ,CAACG,gBAAgB,CAAC,eAAe,EAAGC,KAAK,IAAK;UAClDH,MAAM,CAACpB,IAAI,CAACuB,KAAK,CAAChB,IAAI,CAAC;QAC3B,CAAC,CAAC;QACFY,QAAQ,CAACG,gBAAgB,CAAC,MAAM,EAAE,MAAM;UACpCV,OAAO,CAAC,IAAIY,IAAI,CAACJ,MAAM,EAAE;YAAE7B,IAAI,EAAEK;UAAS,CAAC,CAAC,CAAC;QACjD,CAAC,CAAC;QACFuB,QAAQ,CAACM,KAAK,CAAC,CAAC;QAChBC,UAAU,CAAC,MAAM;UACbP,QAAQ,CAACQ,IAAI,CAAC,CAAC;QACnB,CAAC,EAAEpB,IAAI,CAACqB,QAAQ,IAAIP,eAAe,GAAGnC,qBAAqB,CAAC;MAChE,CAAC,CAAC;IACN,CAAC;IACD,IAAI,CAACuB,UAAU,GAAGN,SAAS;IAC3B,IAAI,CAAC0B,OAAO,GAAGzB,MAAM;IACrB,IAAI,CAACC,eAAe,GAAGhB,0BAA0B,CAAC,CAAC;EACvD;EACA,MAAMyC,MAAMA,CAACvC,IAAI,EAAEgB,IAAI,EAAE;IACrB,MAAMwB,GAAG,GAAG;MACRrC,SAAS,EAAE;IACf,CAAC;IACD,QAAQH,IAAI;MACR,KAAK,OAAO;QACRwC,GAAG,CAACrC,SAAS,GAAG,IAAI;QACpBqC,GAAG,CAACC,IAAI,GAAG,MAAM,IAAI,CAAC1B,YAAY,CAACC,IAAI,CAAC;QACxC;IACR;IACA,OAAOwB,GAAG;EACd;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}