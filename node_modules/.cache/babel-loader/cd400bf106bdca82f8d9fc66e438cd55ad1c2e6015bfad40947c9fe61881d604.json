{"ast":null,"code":"import { clamp, executeOnSingleOrMultiple, getLogger, isArray, isNumber, itemFromArray, itemFromSingleOrMultiple, mouseDownEvent, percentDenominator, touchStartEvent } from \"@tsparticles/engine\";\nimport { ImageDisplay, SoundsEventType } from \"./enums.js\";\nimport { getNoteFrequency, isWindowMuted, unmuteWindow } from \"./utils.js\";\nconst zIndexOffset = 1,\n  rightOffset = 1,\n  minVolume = 0;\nfunction initImage(data) {\n  const img = document.createElement(\"img\"),\n    {\n      clickCb,\n      container,\n      display,\n      iconOptions,\n      margin,\n      options,\n      pos,\n      rightOffsets\n    } = data,\n    {\n      width,\n      path,\n      style,\n      svg\n    } = iconOptions,\n    defaultAccumulator = 0;\n  setIconStyle(img, pos.top + margin, pos.right - (margin * (rightOffsets.length + rightOffset) + width + rightOffsets.reduce((a, b) => a + b, defaultAccumulator)), display, options.fullScreen.zIndex + zIndexOffset, width, margin, style);\n  img.src = path ?? (svg ? `data:image/svg+xml;base64,${btoa(svg)}` : \"\");\n  const parent = container.canvas.element?.parentNode ?? document.body;\n  parent.append(img);\n  img.addEventListener(\"click\", () => {\n    void clickCb();\n  });\n  return img;\n}\nfunction removeImage(image) {\n  if (!image) {\n    return;\n  }\n  image.remove();\n}\nfunction setIconStyle(icon, top, left, display, zIndex, width, margin, style) {\n  icon.style.userSelect = \"none\";\n  icon.style.webkitUserSelect = \"none\";\n  icon.style.position = \"absolute\";\n  icon.style.top = `${top + margin}px`;\n  icon.style.left = `${left - margin - width}px`;\n  icon.style.display = display;\n  icon.style.zIndex = `${zIndex + zIndexOffset}`;\n  icon.style.cssText += style;\n}\nexport class SoundsInstance {\n  constructor(container, engine) {\n    this._addBuffer = audioCtx => {\n      const buffer = audioCtx.createBufferSource();\n      this._audioSources.push(buffer);\n      return buffer;\n    };\n    this._addOscillator = audioCtx => {\n      const oscillator = audioCtx.createOscillator();\n      this._audioSources.push(oscillator);\n      return oscillator;\n    };\n    this._initEvents = () => {\n      const container = this._container,\n        soundsOptions = container.actualOptions.sounds;\n      if (!soundsOptions?.enable || !container.canvas.element) {\n        return;\n      }\n      for (const event of soundsOptions.events) {\n        const cb = args => {\n          void (async () => {\n            const filterNotValid = event.filter && !event.filter(args);\n            if (this._container !== args.container) {\n              return;\n            }\n            if (!this._container || !!this._container.muted || this._container.destroyed) {\n              executeOnSingleOrMultiple(event.event, item => {\n                this._engine.removeEventListener(item, cb);\n              });\n              return;\n            }\n            if (filterNotValid) {\n              return;\n            }\n            const defaultNoteIndex = 0;\n            if (event.audio) {\n              this._playBuffer(itemFromSingleOrMultiple(event.audio));\n            } else if (event.melodies) {\n              const melody = itemFromArray(event.melodies);\n              if (melody.melodies.length) {\n                await Promise.allSettled(melody.melodies.map(m => this._playNote(m.notes, defaultNoteIndex, melody.loop)));\n              } else {\n                await this._playNote(melody.notes, defaultNoteIndex, melody.loop);\n              }\n            } else if (event.notes) {\n              const note = itemFromArray(event.notes);\n              await this._playNote([note], defaultNoteIndex, false);\n            }\n          })();\n        };\n        executeOnSingleOrMultiple(event.event, item => {\n          this._engine.addEventListener(item, cb);\n        });\n      }\n    };\n    this._mute = async () => {\n      const container = this._container,\n        audioContext = this._getAudioContext();\n      for (const source of this._audioSources) {\n        this._removeAudioSource(source);\n      }\n      if (this._gain) {\n        this._gain.disconnect();\n      }\n      await audioContext.close();\n      container.audioContext = undefined;\n      this._engine.dispatchEvent(SoundsEventType.mute, {\n        container: this._container\n      });\n    };\n    this._playBuffer = audio => {\n      const audioBuffer = this._audioMap.get(audio.source);\n      if (!audioBuffer) {\n        return;\n      }\n      const audioCtx = this._container.audioContext;\n      if (!audioCtx) {\n        return;\n      }\n      const source = this._addBuffer(audioCtx);\n      source.loop = audio.loop;\n      source.buffer = audioBuffer;\n      source.connect(this._gain ?? audioCtx.destination);\n      source.start();\n    };\n    this._playFrequency = async (frequency, duration) => {\n      if (!this._gain || this._container.muted) {\n        return;\n      }\n      const audioContext = this._getAudioContext(),\n        oscillator = this._addOscillator(audioContext);\n      oscillator.connect(this._gain);\n      oscillator.type = \"sine\";\n      oscillator.frequency.value = frequency;\n      oscillator.start();\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this._removeAudioSource(oscillator);\n          resolve();\n        }, duration);\n      });\n    };\n    this._playMuteSound = () => {\n      if (this._container.muted) {\n        return;\n      }\n      const audioContext = this._getAudioContext(),\n        gain = audioContext.createGain();\n      gain.connect(audioContext.destination);\n      gain.gain.value = 0;\n      const oscillator = audioContext.createOscillator();\n      oscillator.connect(gain);\n      oscillator.type = \"sine\";\n      oscillator.frequency.value = 1;\n      oscillator.start();\n      setTimeout(() => {\n        oscillator.stop();\n        oscillator.disconnect();\n        gain.disconnect();\n      });\n    };\n    this._playNote = async (notes, noteIdx, loop) => {\n      if (this._container.muted) {\n        return;\n      }\n      const note = notes[noteIdx];\n      if (!note) {\n        return;\n      }\n      const value = note.value;\n      const promises = executeOnSingleOrMultiple(value, async (_, idx) => {\n        return this._playNoteValue(notes, noteIdx, idx);\n      });\n      await (isArray(promises) ? Promise.allSettled(promises) : promises);\n      const indexOffset = 1;\n      let nextNoteIdx = noteIdx + indexOffset;\n      if (loop && nextNoteIdx >= notes.length) {\n        nextNoteIdx = nextNoteIdx % notes.length;\n      }\n      if (this._container.muted) {\n        return;\n      }\n      await this._playNote(notes, nextNoteIdx, loop);\n    };\n    this._playNoteValue = async (notes, noteIdx, valueIdx) => {\n      const note = notes[noteIdx];\n      if (!note) {\n        return;\n      }\n      const value = itemFromSingleOrMultiple(note.value, valueIdx, true);\n      try {\n        const freq = getNoteFrequency(value);\n        if (!isNumber(freq)) {\n          return;\n        }\n        await this._playFrequency(freq, note.duration);\n      } catch (e) {\n        getLogger().error(e);\n      }\n    };\n    this._removeAudioSource = source => {\n      source.stop();\n      source.disconnect();\n      const deleteCount = 1;\n      this._audioSources.splice(this._audioSources.indexOf(source), deleteCount);\n    };\n    this._unmute = () => {\n      const container = this._container,\n        options = container.actualOptions,\n        soundsOptions = options.sounds;\n      if (!soundsOptions) {\n        return;\n      }\n      const audioContext = this._getAudioContext();\n      if (!this._audioSources) {\n        this._audioSources = [];\n      }\n      const gain = audioContext.createGain();\n      gain.connect(audioContext.destination);\n      gain.gain.value = soundsOptions.volume.value / percentDenominator;\n      this._gain = gain;\n      this._initEvents();\n      this._engine.dispatchEvent(SoundsEventType.unmute, {\n        container: this._container\n      });\n    };\n    this._updateMuteIcons = () => {\n      const container = this._container,\n        soundsOptions = container.actualOptions.sounds;\n      if (!soundsOptions?.enable || !soundsOptions.icons.enable) {\n        return;\n      }\n      const muteImg = this._muteImg,\n        unmuteImg = this._unmuteImg;\n      if (muteImg) {\n        muteImg.style.display = container.muted ? \"block\" : \"none\";\n      }\n      if (unmuteImg) {\n        unmuteImg.style.display = container.muted ? \"none\" : \"block\";\n      }\n    };\n    this._updateMuteStatus = async () => {\n      const container = this._container,\n        audioContext = this._getAudioContext();\n      if (container.muted) {\n        await audioContext?.suspend();\n        await this._mute();\n      } else {\n        await audioContext?.resume();\n        this._unmute();\n        this._playMuteSound();\n      }\n    };\n    this._updateVolume = async () => {\n      const container = this._container,\n        soundsOptions = container.actualOptions.sounds;\n      if (!soundsOptions?.enable) {\n        return;\n      }\n      clamp(this._volume, soundsOptions.volume.min, soundsOptions.volume.max);\n      let stateChanged = false;\n      if (this._volume <= minVolume && !container.muted) {\n        this._volume = 0;\n        container.muted = true;\n        stateChanged = true;\n      } else if (this._volume > minVolume && container.muted) {\n        container.muted = false;\n        stateChanged = true;\n      }\n      if (stateChanged) {\n        this._updateMuteIcons();\n        await this._updateMuteStatus();\n      }\n      if (this._gain?.gain) {\n        this._gain.gain.value = this._volume / percentDenominator;\n      }\n    };\n    this._container = container;\n    this._engine = engine;\n    this._volume = 0;\n    this._audioSources = [];\n    this._audioMap = new Map();\n  }\n  async init() {\n    const container = this._container,\n      options = container.actualOptions,\n      soundsOptions = options.sounds;\n    if (!soundsOptions?.enable) {\n      return;\n    }\n    if (soundsOptions.autoPlay && isWindowMuted()) {\n      const firstClickHandler = () => {\n        removeEventListener(mouseDownEvent, firstClickHandler);\n        removeEventListener(touchStartEvent, firstClickHandler);\n        unmuteWindow();\n        void this.unmute();\n      };\n      const listenerOptions = {\n        capture: true,\n        once: true\n      };\n      addEventListener(mouseDownEvent, firstClickHandler, listenerOptions);\n      addEventListener(touchStartEvent, firstClickHandler, listenerOptions);\n    }\n    this._volume = soundsOptions.volume.value;\n    const events = soundsOptions.events;\n    this._audioMap = new Map();\n    for (const event of events) {\n      if (!event.audio) {\n        continue;\n      }\n      const promises = executeOnSingleOrMultiple(event.audio, async audio => {\n        const response = await fetch(audio.source);\n        if (!response.ok) {\n          return;\n        }\n        const arrayBuffer = await response.arrayBuffer(),\n          audioContext = this._getAudioContext(),\n          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        this._audioMap.set(audio.source, audioBuffer);\n      });\n      if (promises instanceof Promise) {\n        await promises;\n      } else {\n        await Promise.allSettled(promises);\n      }\n    }\n  }\n  async mute() {\n    if (!this._container.muted) {\n      await this.toggleMute();\n    }\n  }\n  async start() {\n    const container = this._container,\n      options = container.actualOptions,\n      soundsOptions = options.sounds;\n    if (!soundsOptions?.enable || !container.canvas.element) {\n      return;\n    }\n    container.muted = true;\n    const canvas = container.canvas.element,\n      pos = {\n        top: canvas.offsetTop,\n        right: canvas.offsetLeft + canvas.offsetWidth\n      },\n      {\n        mute,\n        unmute,\n        volumeDown,\n        volumeUp\n      } = soundsOptions.icons,\n      margin = 10,\n      toggleMute = async () => {\n        await this.toggleMute();\n      },\n      enableIcons = soundsOptions.icons.enable,\n      display = enableIcons ? ImageDisplay.Block : ImageDisplay.None;\n    this._muteImg = initImage({\n      container,\n      options,\n      pos,\n      display,\n      iconOptions: mute,\n      margin,\n      rightOffsets: [volumeDown.width, volumeUp.width],\n      clickCb: toggleMute\n    });\n    this._unmuteImg = initImage({\n      container,\n      options,\n      pos,\n      display: ImageDisplay.None,\n      iconOptions: unmute,\n      margin,\n      rightOffsets: [volumeDown.width, volumeUp.width],\n      clickCb: toggleMute\n    });\n    this._volumeDownImg = initImage({\n      container,\n      options,\n      pos,\n      display,\n      iconOptions: volumeDown,\n      margin,\n      rightOffsets: [volumeUp.width],\n      clickCb: async () => {\n        await this.volumeDown();\n      }\n    });\n    this._volumeUpImg = initImage({\n      container,\n      options,\n      pos,\n      display,\n      iconOptions: volumeUp,\n      margin,\n      rightOffsets: [],\n      clickCb: async () => {\n        await this.volumeUp();\n      }\n    });\n    if (!isWindowMuted() && soundsOptions.autoPlay) {\n      await this.unmute();\n    }\n  }\n  stop() {\n    this._container.muted = true;\n    void (async () => {\n      await this._mute();\n      removeImage(this._muteImg);\n      removeImage(this._unmuteImg);\n      removeImage(this._volumeDownImg);\n      removeImage(this._volumeUpImg);\n    })();\n  }\n  async toggleMute() {\n    const container = this._container;\n    container.muted = !container.muted;\n    this._updateMuteIcons();\n    await this._updateMuteStatus();\n  }\n  async unmute() {\n    if (this._container.muted) {\n      await this.toggleMute();\n    }\n  }\n  async volumeDown() {\n    const container = this._container,\n      soundsOptions = container.actualOptions.sounds;\n    if (!soundsOptions?.enable) {\n      return;\n    }\n    if (container.muted) {\n      this._volume = 0;\n    }\n    this._volume -= soundsOptions.volume.step;\n    await this._updateVolume();\n  }\n  async volumeUp() {\n    const container = this._container,\n      soundsOptions = container.actualOptions.sounds;\n    if (!soundsOptions?.enable) {\n      return;\n    }\n    this._volume += soundsOptions.volume.step;\n    await this._updateVolume();\n  }\n  _getAudioContext() {\n    const container = this._container;\n    if (!container.audioContext) {\n      container.audioContext = new AudioContext();\n    }\n    return container.audioContext;\n  }\n}","map":{"version":3,"names":["clamp","executeOnSingleOrMultiple","getLogger","isArray","isNumber","itemFromArray","itemFromSingleOrMultiple","mouseDownEvent","percentDenominator","touchStartEvent","ImageDisplay","SoundsEventType","getNoteFrequency","isWindowMuted","unmuteWindow","zIndexOffset","rightOffset","minVolume","initImage","data","img","document","createElement","clickCb","container","display","iconOptions","margin","options","pos","rightOffsets","width","path","style","svg","defaultAccumulator","setIconStyle","top","right","length","reduce","a","b","fullScreen","zIndex","src","btoa","parent","canvas","element","parentNode","body","append","addEventListener","removeImage","image","remove","icon","left","userSelect","webkitUserSelect","position","cssText","SoundsInstance","constructor","engine","_addBuffer","audioCtx","buffer","createBufferSource","_audioSources","push","_addOscillator","oscillator","createOscillator","_initEvents","_container","soundsOptions","actualOptions","sounds","enable","event","events","cb","args","filterNotValid","filter","muted","destroyed","item","_engine","removeEventListener","defaultNoteIndex","audio","_playBuffer","melodies","melody","Promise","allSettled","map","m","_playNote","notes","loop","note","_mute","audioContext","_getAudioContext","source","_removeAudioSource","_gain","disconnect","close","undefined","dispatchEvent","mute","audioBuffer","_audioMap","get","connect","destination","start","_playFrequency","frequency","duration","type","value","resolve","setTimeout","_playMuteSound","gain","createGain","stop","noteIdx","promises","_","idx","_playNoteValue","indexOffset","nextNoteIdx","valueIdx","freq","e","error","deleteCount","splice","indexOf","_unmute","volume","unmute","_updateMuteIcons","icons","muteImg","_muteImg","unmuteImg","_unmuteImg","_updateMuteStatus","suspend","resume","_updateVolume","_volume","min","max","stateChanged","Map","init","autoPlay","firstClickHandler","listenerOptions","capture","once","response","fetch","ok","arrayBuffer","decodeAudioData","set","toggleMute","offsetTop","offsetLeft","offsetWidth","volumeDown","volumeUp","enableIcons","Block","None","_volumeDownImg","_volumeUpImg","step","AudioContext"],"sources":["/Users/nyanaung/repos/portfolio/node_modules/@tsparticles/plugin-sounds/browser/SoundsInstance.js"],"sourcesContent":["import { clamp, executeOnSingleOrMultiple, getLogger, isArray, isNumber, itemFromArray, itemFromSingleOrMultiple, mouseDownEvent, percentDenominator, touchStartEvent, } from \"@tsparticles/engine\";\nimport { ImageDisplay, SoundsEventType } from \"./enums.js\";\nimport { getNoteFrequency, isWindowMuted, unmuteWindow } from \"./utils.js\";\nconst zIndexOffset = 1, rightOffset = 1, minVolume = 0;\nfunction initImage(data) {\n    const img = document.createElement(\"img\"), { clickCb, container, display, iconOptions, margin, options, pos, rightOffsets } = data, { width, path, style, svg } = iconOptions, defaultAccumulator = 0;\n    setIconStyle(img, pos.top + margin, pos.right -\n        (margin * (rightOffsets.length + rightOffset) +\n            width +\n            rightOffsets.reduce((a, b) => a + b, defaultAccumulator)), display, options.fullScreen.zIndex + zIndexOffset, width, margin, style);\n    img.src = path ?? (svg ? `data:image/svg+xml;base64,${btoa(svg)}` : \"\");\n    const parent = container.canvas.element?.parentNode ?? document.body;\n    parent.append(img);\n    img.addEventListener(\"click\", () => {\n        void clickCb();\n    });\n    return img;\n}\nfunction removeImage(image) {\n    if (!image) {\n        return;\n    }\n    image.remove();\n}\nfunction setIconStyle(icon, top, left, display, zIndex, width, margin, style) {\n    icon.style.userSelect = \"none\";\n    icon.style.webkitUserSelect = \"none\";\n    icon.style.position = \"absolute\";\n    icon.style.top = `${top + margin}px`;\n    icon.style.left = `${left - margin - width}px`;\n    icon.style.display = display;\n    icon.style.zIndex = `${zIndex + zIndexOffset}`;\n    icon.style.cssText += style;\n}\nexport class SoundsInstance {\n    constructor(container, engine) {\n        this._addBuffer = audioCtx => {\n            const buffer = audioCtx.createBufferSource();\n            this._audioSources.push(buffer);\n            return buffer;\n        };\n        this._addOscillator = audioCtx => {\n            const oscillator = audioCtx.createOscillator();\n            this._audioSources.push(oscillator);\n            return oscillator;\n        };\n        this._initEvents = () => {\n            const container = this._container, soundsOptions = container.actualOptions.sounds;\n            if (!soundsOptions?.enable || !container.canvas.element) {\n                return;\n            }\n            for (const event of soundsOptions.events) {\n                const cb = (args) => {\n                    void (async () => {\n                        const filterNotValid = event.filter && !event.filter(args);\n                        if (this._container !== args.container) {\n                            return;\n                        }\n                        if (!this._container || !!this._container.muted || this._container.destroyed) {\n                            executeOnSingleOrMultiple(event.event, item => {\n                                this._engine.removeEventListener(item, cb);\n                            });\n                            return;\n                        }\n                        if (filterNotValid) {\n                            return;\n                        }\n                        const defaultNoteIndex = 0;\n                        if (event.audio) {\n                            this._playBuffer(itemFromSingleOrMultiple(event.audio));\n                        }\n                        else if (event.melodies) {\n                            const melody = itemFromArray(event.melodies);\n                            if (melody.melodies.length) {\n                                await Promise.allSettled(melody.melodies.map(m => this._playNote(m.notes, defaultNoteIndex, melody.loop)));\n                            }\n                            else {\n                                await this._playNote(melody.notes, defaultNoteIndex, melody.loop);\n                            }\n                        }\n                        else if (event.notes) {\n                            const note = itemFromArray(event.notes);\n                            await this._playNote([note], defaultNoteIndex, false);\n                        }\n                    })();\n                };\n                executeOnSingleOrMultiple(event.event, item => {\n                    this._engine.addEventListener(item, cb);\n                });\n            }\n        };\n        this._mute = async () => {\n            const container = this._container, audioContext = this._getAudioContext();\n            for (const source of this._audioSources) {\n                this._removeAudioSource(source);\n            }\n            if (this._gain) {\n                this._gain.disconnect();\n            }\n            await audioContext.close();\n            container.audioContext = undefined;\n            this._engine.dispatchEvent(SoundsEventType.mute, { container: this._container });\n        };\n        this._playBuffer = audio => {\n            const audioBuffer = this._audioMap.get(audio.source);\n            if (!audioBuffer) {\n                return;\n            }\n            const audioCtx = this._container.audioContext;\n            if (!audioCtx) {\n                return;\n            }\n            const source = this._addBuffer(audioCtx);\n            source.loop = audio.loop;\n            source.buffer = audioBuffer;\n            source.connect(this._gain ?? audioCtx.destination);\n            source.start();\n        };\n        this._playFrequency = async (frequency, duration) => {\n            if (!this._gain || this._container.muted) {\n                return;\n            }\n            const audioContext = this._getAudioContext(), oscillator = this._addOscillator(audioContext);\n            oscillator.connect(this._gain);\n            oscillator.type = \"sine\";\n            oscillator.frequency.value = frequency;\n            oscillator.start();\n            return new Promise(resolve => {\n                setTimeout(() => {\n                    this._removeAudioSource(oscillator);\n                    resolve();\n                }, duration);\n            });\n        };\n        this._playMuteSound = () => {\n            if (this._container.muted) {\n                return;\n            }\n            const audioContext = this._getAudioContext(), gain = audioContext.createGain();\n            gain.connect(audioContext.destination);\n            gain.gain.value = 0;\n            const oscillator = audioContext.createOscillator();\n            oscillator.connect(gain);\n            oscillator.type = \"sine\";\n            oscillator.frequency.value = 1;\n            oscillator.start();\n            setTimeout(() => {\n                oscillator.stop();\n                oscillator.disconnect();\n                gain.disconnect();\n            });\n        };\n        this._playNote = async (notes, noteIdx, loop) => {\n            if (this._container.muted) {\n                return;\n            }\n            const note = notes[noteIdx];\n            if (!note) {\n                return;\n            }\n            const value = note.value;\n            const promises = executeOnSingleOrMultiple(value, async (_, idx) => {\n                return this._playNoteValue(notes, noteIdx, idx);\n            });\n            await (isArray(promises) ? Promise.allSettled(promises) : promises);\n            const indexOffset = 1;\n            let nextNoteIdx = noteIdx + indexOffset;\n            if (loop && nextNoteIdx >= notes.length) {\n                nextNoteIdx = nextNoteIdx % notes.length;\n            }\n            if (this._container.muted) {\n                return;\n            }\n            await this._playNote(notes, nextNoteIdx, loop);\n        };\n        this._playNoteValue = async (notes, noteIdx, valueIdx) => {\n            const note = notes[noteIdx];\n            if (!note) {\n                return;\n            }\n            const value = itemFromSingleOrMultiple(note.value, valueIdx, true);\n            try {\n                const freq = getNoteFrequency(value);\n                if (!isNumber(freq)) {\n                    return;\n                }\n                await this._playFrequency(freq, note.duration);\n            }\n            catch (e) {\n                getLogger().error(e);\n            }\n        };\n        this._removeAudioSource = source => {\n            source.stop();\n            source.disconnect();\n            const deleteCount = 1;\n            this._audioSources.splice(this._audioSources.indexOf(source), deleteCount);\n        };\n        this._unmute = () => {\n            const container = this._container, options = container.actualOptions, soundsOptions = options.sounds;\n            if (!soundsOptions) {\n                return;\n            }\n            const audioContext = this._getAudioContext();\n            if (!this._audioSources) {\n                this._audioSources = [];\n            }\n            const gain = audioContext.createGain();\n            gain.connect(audioContext.destination);\n            gain.gain.value = soundsOptions.volume.value / percentDenominator;\n            this._gain = gain;\n            this._initEvents();\n            this._engine.dispatchEvent(SoundsEventType.unmute, { container: this._container });\n        };\n        this._updateMuteIcons = () => {\n            const container = this._container, soundsOptions = container.actualOptions.sounds;\n            if (!soundsOptions?.enable || !soundsOptions.icons.enable) {\n                return;\n            }\n            const muteImg = this._muteImg, unmuteImg = this._unmuteImg;\n            if (muteImg) {\n                muteImg.style.display = container.muted ? \"block\" : \"none\";\n            }\n            if (unmuteImg) {\n                unmuteImg.style.display = container.muted ? \"none\" : \"block\";\n            }\n        };\n        this._updateMuteStatus = async () => {\n            const container = this._container, audioContext = this._getAudioContext();\n            if (container.muted) {\n                await audioContext?.suspend();\n                await this._mute();\n            }\n            else {\n                await audioContext?.resume();\n                this._unmute();\n                this._playMuteSound();\n            }\n        };\n        this._updateVolume = async () => {\n            const container = this._container, soundsOptions = container.actualOptions.sounds;\n            if (!soundsOptions?.enable) {\n                return;\n            }\n            clamp(this._volume, soundsOptions.volume.min, soundsOptions.volume.max);\n            let stateChanged = false;\n            if (this._volume <= minVolume && !container.muted) {\n                this._volume = 0;\n                container.muted = true;\n                stateChanged = true;\n            }\n            else if (this._volume > minVolume && container.muted) {\n                container.muted = false;\n                stateChanged = true;\n            }\n            if (stateChanged) {\n                this._updateMuteIcons();\n                await this._updateMuteStatus();\n            }\n            if (this._gain?.gain) {\n                this._gain.gain.value = this._volume / percentDenominator;\n            }\n        };\n        this._container = container;\n        this._engine = engine;\n        this._volume = 0;\n        this._audioSources = [];\n        this._audioMap = new Map();\n    }\n    async init() {\n        const container = this._container, options = container.actualOptions, soundsOptions = options.sounds;\n        if (!soundsOptions?.enable) {\n            return;\n        }\n        if (soundsOptions.autoPlay && isWindowMuted()) {\n            const firstClickHandler = () => {\n                removeEventListener(mouseDownEvent, firstClickHandler);\n                removeEventListener(touchStartEvent, firstClickHandler);\n                unmuteWindow();\n                void this.unmute();\n            };\n            const listenerOptions = {\n                capture: true,\n                once: true,\n            };\n            addEventListener(mouseDownEvent, firstClickHandler, listenerOptions);\n            addEventListener(touchStartEvent, firstClickHandler, listenerOptions);\n        }\n        this._volume = soundsOptions.volume.value;\n        const events = soundsOptions.events;\n        this._audioMap = new Map();\n        for (const event of events) {\n            if (!event.audio) {\n                continue;\n            }\n            const promises = executeOnSingleOrMultiple(event.audio, async (audio) => {\n                const response = await fetch(audio.source);\n                if (!response.ok) {\n                    return;\n                }\n                const arrayBuffer = await response.arrayBuffer(), audioContext = this._getAudioContext(), audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n                this._audioMap.set(audio.source, audioBuffer);\n            });\n            if (promises instanceof Promise) {\n                await promises;\n            }\n            else {\n                await Promise.allSettled(promises);\n            }\n        }\n    }\n    async mute() {\n        if (!this._container.muted) {\n            await this.toggleMute();\n        }\n    }\n    async start() {\n        const container = this._container, options = container.actualOptions, soundsOptions = options.sounds;\n        if (!soundsOptions?.enable || !container.canvas.element) {\n            return;\n        }\n        container.muted = true;\n        const canvas = container.canvas.element, pos = {\n            top: canvas.offsetTop,\n            right: canvas.offsetLeft + canvas.offsetWidth,\n        }, { mute, unmute, volumeDown, volumeUp } = soundsOptions.icons, margin = 10, toggleMute = async () => {\n            await this.toggleMute();\n        }, enableIcons = soundsOptions.icons.enable, display = enableIcons ? ImageDisplay.Block : ImageDisplay.None;\n        this._muteImg = initImage({\n            container,\n            options,\n            pos,\n            display,\n            iconOptions: mute,\n            margin,\n            rightOffsets: [volumeDown.width, volumeUp.width],\n            clickCb: toggleMute,\n        });\n        this._unmuteImg = initImage({\n            container,\n            options,\n            pos,\n            display: ImageDisplay.None,\n            iconOptions: unmute,\n            margin,\n            rightOffsets: [volumeDown.width, volumeUp.width],\n            clickCb: toggleMute,\n        });\n        this._volumeDownImg = initImage({\n            container,\n            options,\n            pos,\n            display,\n            iconOptions: volumeDown,\n            margin,\n            rightOffsets: [volumeUp.width],\n            clickCb: async () => {\n                await this.volumeDown();\n            },\n        });\n        this._volumeUpImg = initImage({\n            container,\n            options,\n            pos,\n            display,\n            iconOptions: volumeUp,\n            margin,\n            rightOffsets: [],\n            clickCb: async () => {\n                await this.volumeUp();\n            },\n        });\n        if (!isWindowMuted() && soundsOptions.autoPlay) {\n            await this.unmute();\n        }\n    }\n    stop() {\n        this._container.muted = true;\n        void (async () => {\n            await this._mute();\n            removeImage(this._muteImg);\n            removeImage(this._unmuteImg);\n            removeImage(this._volumeDownImg);\n            removeImage(this._volumeUpImg);\n        })();\n    }\n    async toggleMute() {\n        const container = this._container;\n        container.muted = !container.muted;\n        this._updateMuteIcons();\n        await this._updateMuteStatus();\n    }\n    async unmute() {\n        if (this._container.muted) {\n            await this.toggleMute();\n        }\n    }\n    async volumeDown() {\n        const container = this._container, soundsOptions = container.actualOptions.sounds;\n        if (!soundsOptions?.enable) {\n            return;\n        }\n        if (container.muted) {\n            this._volume = 0;\n        }\n        this._volume -= soundsOptions.volume.step;\n        await this._updateVolume();\n    }\n    async volumeUp() {\n        const container = this._container, soundsOptions = container.actualOptions.sounds;\n        if (!soundsOptions?.enable) {\n            return;\n        }\n        this._volume += soundsOptions.volume.step;\n        await this._updateVolume();\n    }\n    _getAudioContext() {\n        const container = this._container;\n        if (!container.audioContext) {\n            container.audioContext = new AudioContext();\n        }\n        return container.audioContext;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}