{"ast":null,"code":"import { PixelMode, Vector, getPosition, getRandom, half, randomInRange } from \"@tsparticles/engine\";\nvar SVGPathDirection;\n(function (SVGPathDirection) {\n  SVGPathDirection[SVGPathDirection[\"normal\"] = 0] = \"normal\";\n  SVGPathDirection[SVGPathDirection[\"reverse\"] = 1] = \"reverse\";\n})(SVGPathDirection || (SVGPathDirection = {}));\nconst defaultSpeed = 1,\n  minStep = 0,\n  minIndex = 0,\n  minWidth = 0,\n  minScale = 1;\nexport class SVGPathGenerator {\n  constructor() {\n    this._paths = [];\n    this._reverse = false;\n    this._size = {\n      width: 0,\n      height: 0\n    };\n    this._scale = 1;\n    this._offset = {\n      x: 0,\n      y: 0,\n      mode: PixelMode.percent\n    };\n    this._width = 0;\n  }\n  generate(particle, delta) {\n    const container = particle.container,\n      pxRatio = container.retina.pixelRatio;\n    if (particle.svgDirection === undefined) {\n      particle.svgDirection = getRandom() > half ? SVGPathDirection.normal : SVGPathDirection.reverse;\n    }\n    if (particle.svgPathIndex === undefined) {\n      particle.svgPathIndex = Math.floor(getRandom() * this._paths.length);\n    }\n    if (particle.svgSpeed === undefined) {\n      particle.svgSpeed = particle.velocity.mult((particle.retina.moveSpeed ?? defaultSpeed) * half).length;\n    }\n    if (particle.svgStep === undefined) {\n      particle.svgStep = randomInRange({\n        min: 0,\n        max: this._paths[particle.svgPathIndex].length\n      }) * pxRatio;\n    }\n    if (particle.svgOffset === undefined) {\n      particle.svgOffset = {\n        width: randomInRange({\n          min: -this._width * half,\n          max: this._width * half\n        }) * pxRatio,\n        height: randomInRange({\n          min: -this._width * half,\n          max: this._width * half\n        }) * pxRatio\n      };\n    }\n    if (particle.svgInitialPosition === undefined) {\n      particle.svgInitialPosition = {\n        ...particle.position\n      };\n    }\n    particle.velocity.x = 0;\n    particle.velocity.y = 0;\n    if (particle.svgDirection === SVGPathDirection.normal) {\n      particle.svgStep += particle.svgSpeed * delta.factor;\n    } else {\n      particle.svgStep -= particle.svgSpeed * delta.factor;\n    }\n    let path = this._paths[particle.svgPathIndex];\n    if (path) {\n      const pathLength = path.length,\n        indexOffset = 1;\n      if (particle.svgStep >= pathLength) {\n        particle.svgPathIndex = particle.svgPathIndex + indexOffset;\n        if (particle.svgPathIndex >= this._paths.length) {\n          if (this._reverse) {\n            particle.svgPathIndex = this._paths.length - indexOffset;\n            particle.svgDirection = SVGPathDirection.reverse;\n          } else {\n            particle.svgPathIndex = 0;\n            particle.svgStep = 0;\n          }\n        }\n      } else if (particle.svgStep <= minStep) {\n        particle.svgPathIndex = particle.svgPathIndex - indexOffset;\n        if (particle.svgPathIndex < minIndex) {\n          if (this._reverse) {\n            particle.svgPathIndex = 0;\n            particle.svgDirection = SVGPathDirection.normal;\n          } else {\n            particle.svgPathIndex = this._paths.length - indexOffset;\n            path = this._paths[particle.svgPathIndex];\n            particle.svgStep = path.length;\n          }\n        }\n      }\n      path = this._paths[particle.svgPathIndex];\n    }\n    if (path) {\n      const pathElement = path.element,\n        pos = pathElement.getPointAtLength(particle.svgStep),\n        canvasSize = particle.container.canvas.size,\n        offset = getPosition(this._offset, canvasSize),\n        scale = this._scale * pxRatio;\n      particle.position.x = (pos.x - this._size.width * half) * scale + particle.svgInitialPosition.x + offset.x + particle.svgOffset.width;\n      particle.position.y = (pos.y - this._size.height * half) * scale + particle.svgInitialPosition.y + offset.y + particle.svgOffset.height;\n    }\n    return Vector.origin;\n  }\n  init(container) {\n    const options = container.actualOptions.particles.move.path.options,\n      position = options.position ?? this._offset;\n    this._reverse = options.reverse ?? this._reverse;\n    this._scale = options.scale ?? minScale;\n    this._offset.x = position.x;\n    this._offset.y = position.y;\n    this._offset.mode = position.mode;\n    this._width = options.width ?? minWidth;\n    if (options.url && !options.path) {\n      const url = options.url;\n      void (async () => {\n        const response = await fetch(url),\n          data = await response.text();\n        const parser = new DOMParser(),\n          doc = parser.parseFromString(data, \"image/svg+xml\"),\n          firstIndex = 0,\n          svg = doc.getElementsByTagName(\"svg\")[firstIndex];\n        let svgPaths = svg.getElementsByTagName(\"path\");\n        if (!svgPaths.length) {\n          svgPaths = doc.getElementsByTagName(\"path\");\n        }\n        this._paths = [];\n        for (let i = 0; i < svgPaths.length; i++) {\n          const path = svgPaths.item(i);\n          if (path) {\n            this._paths.push({\n              element: path,\n              length: path.getTotalLength()\n            });\n          }\n        }\n        this._size.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\");\n        this._size.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\");\n      })();\n    } else if (options.path) {\n      const path = options.path;\n      this._paths = [];\n      for (const item of path.data) {\n        const element = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        element.setAttribute(\"d\", item);\n        this._paths.push({\n          element,\n          length: element.getTotalLength()\n        });\n      }\n      this._size.height = path.size.height;\n      this._size.width = path.size.width;\n    }\n  }\n  reset() {}\n  update() {}\n}","map":{"version":3,"names":["PixelMode","Vector","getPosition","getRandom","half","randomInRange","SVGPathDirection","defaultSpeed","minStep","minIndex","minWidth","minScale","SVGPathGenerator","constructor","_paths","_reverse","_size","width","height","_scale","_offset","x","y","mode","percent","_width","generate","particle","delta","container","pxRatio","retina","pixelRatio","svgDirection","undefined","normal","reverse","svgPathIndex","Math","floor","length","svgSpeed","velocity","mult","moveSpeed","svgStep","min","max","svgOffset","svgInitialPosition","position","factor","path","pathLength","indexOffset","pathElement","element","pos","getPointAtLength","canvasSize","canvas","size","offset","scale","origin","init","options","actualOptions","particles","move","url","response","fetch","data","text","parser","DOMParser","doc","parseFromString","firstIndex","svg","getElementsByTagName","svgPaths","i","item","push","getTotalLength","parseFloat","getAttribute","document","createElementNS","setAttribute","reset","update"],"sources":["/Users/nyanaung/repos/portfolio/node_modules/@tsparticles/path-svg/browser/SVGPathGenerator.js"],"sourcesContent":["import { PixelMode, Vector, getPosition, getRandom, half, randomInRange, } from \"@tsparticles/engine\";\nvar SVGPathDirection;\n(function (SVGPathDirection) {\n    SVGPathDirection[SVGPathDirection[\"normal\"] = 0] = \"normal\";\n    SVGPathDirection[SVGPathDirection[\"reverse\"] = 1] = \"reverse\";\n})(SVGPathDirection || (SVGPathDirection = {}));\nconst defaultSpeed = 1, minStep = 0, minIndex = 0, minWidth = 0, minScale = 1;\nexport class SVGPathGenerator {\n    constructor() {\n        this._paths = [];\n        this._reverse = false;\n        this._size = { width: 0, height: 0 };\n        this._scale = 1;\n        this._offset = { x: 0, y: 0, mode: PixelMode.percent };\n        this._width = 0;\n    }\n    generate(particle, delta) {\n        const container = particle.container, pxRatio = container.retina.pixelRatio;\n        if (particle.svgDirection === undefined) {\n            particle.svgDirection = getRandom() > half ? SVGPathDirection.normal : SVGPathDirection.reverse;\n        }\n        if (particle.svgPathIndex === undefined) {\n            particle.svgPathIndex = Math.floor(getRandom() * this._paths.length);\n        }\n        if (particle.svgSpeed === undefined) {\n            particle.svgSpeed = particle.velocity.mult((particle.retina.moveSpeed ?? defaultSpeed) * half).length;\n        }\n        if (particle.svgStep === undefined) {\n            particle.svgStep = randomInRange({ min: 0, max: this._paths[particle.svgPathIndex].length }) * pxRatio;\n        }\n        if (particle.svgOffset === undefined) {\n            particle.svgOffset = {\n                width: randomInRange({ min: -this._width * half, max: this._width * half }) * pxRatio,\n                height: randomInRange({ min: -this._width * half, max: this._width * half }) * pxRatio,\n            };\n        }\n        if (particle.svgInitialPosition === undefined) {\n            particle.svgInitialPosition = { ...particle.position };\n        }\n        particle.velocity.x = 0;\n        particle.velocity.y = 0;\n        if (particle.svgDirection === SVGPathDirection.normal) {\n            particle.svgStep += particle.svgSpeed * delta.factor;\n        }\n        else {\n            particle.svgStep -= particle.svgSpeed * delta.factor;\n        }\n        let path = this._paths[particle.svgPathIndex];\n        if (path) {\n            const pathLength = path.length, indexOffset = 1;\n            if (particle.svgStep >= pathLength) {\n                particle.svgPathIndex = particle.svgPathIndex + indexOffset;\n                if (particle.svgPathIndex >= this._paths.length) {\n                    if (this._reverse) {\n                        particle.svgPathIndex = this._paths.length - indexOffset;\n                        particle.svgDirection = SVGPathDirection.reverse;\n                    }\n                    else {\n                        particle.svgPathIndex = 0;\n                        particle.svgStep = 0;\n                    }\n                }\n            }\n            else if (particle.svgStep <= minStep) {\n                particle.svgPathIndex = particle.svgPathIndex - indexOffset;\n                if (particle.svgPathIndex < minIndex) {\n                    if (this._reverse) {\n                        particle.svgPathIndex = 0;\n                        particle.svgDirection = SVGPathDirection.normal;\n                    }\n                    else {\n                        particle.svgPathIndex = this._paths.length - indexOffset;\n                        path = this._paths[particle.svgPathIndex];\n                        particle.svgStep = path.length;\n                    }\n                }\n            }\n            path = this._paths[particle.svgPathIndex];\n        }\n        if (path) {\n            const pathElement = path.element, pos = pathElement.getPointAtLength(particle.svgStep), canvasSize = particle.container.canvas.size, offset = getPosition(this._offset, canvasSize), scale = this._scale * pxRatio;\n            particle.position.x =\n                (pos.x - this._size.width * half) * scale +\n                    particle.svgInitialPosition.x +\n                    offset.x +\n                    particle.svgOffset.width;\n            particle.position.y =\n                (pos.y - this._size.height * half) * scale +\n                    particle.svgInitialPosition.y +\n                    offset.y +\n                    particle.svgOffset.height;\n        }\n        return Vector.origin;\n    }\n    init(container) {\n        const options = container.actualOptions.particles.move.path.options, position = options.position ?? this._offset;\n        this._reverse = options.reverse ?? this._reverse;\n        this._scale = options.scale ?? minScale;\n        this._offset.x = position.x;\n        this._offset.y = position.y;\n        this._offset.mode = position.mode;\n        this._width = options.width ?? minWidth;\n        if (options.url && !options.path) {\n            const url = options.url;\n            void (async () => {\n                const response = await fetch(url), data = await response.text();\n                const parser = new DOMParser(), doc = parser.parseFromString(data, \"image/svg+xml\"), firstIndex = 0, svg = doc.getElementsByTagName(\"svg\")[firstIndex];\n                let svgPaths = svg.getElementsByTagName(\"path\");\n                if (!svgPaths.length) {\n                    svgPaths = doc.getElementsByTagName(\"path\");\n                }\n                this._paths = [];\n                for (let i = 0; i < svgPaths.length; i++) {\n                    const path = svgPaths.item(i);\n                    if (path) {\n                        this._paths.push({\n                            element: path,\n                            length: path.getTotalLength(),\n                        });\n                    }\n                }\n                this._size.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\");\n                this._size.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\");\n            })();\n        }\n        else if (options.path) {\n            const path = options.path;\n            this._paths = [];\n            for (const item of path.data) {\n                const element = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n                element.setAttribute(\"d\", item);\n                this._paths.push({\n                    element,\n                    length: element.getTotalLength(),\n                });\n            }\n            this._size.height = path.size.height;\n            this._size.width = path.size.width;\n        }\n    }\n    reset() {\n    }\n    update() {\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}