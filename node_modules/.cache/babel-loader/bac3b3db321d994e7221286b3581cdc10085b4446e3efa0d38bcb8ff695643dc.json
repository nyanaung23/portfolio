{"ast":null,"code":"import { Vector, getDistances, getStyleFromRgb, rangeColorToRgb } from \"@tsparticles/engine\";\nconst squareExp = 2,\n  inSegmentRange = {\n    min: 0,\n    max: 1\n  },\n  double = 2;\nexport function drawPolygonMask(engine, context, rawData, stroke) {\n  const color = rangeColorToRgb(engine, stroke.color);\n  if (!color) {\n    return;\n  }\n  const firstIndex = 0,\n    firstItem = rawData[firstIndex];\n  context.beginPath();\n  context.moveTo(firstItem.x, firstItem.y);\n  for (const item of rawData) {\n    context.lineTo(item.x, item.y);\n  }\n  context.closePath();\n  context.strokeStyle = getStyleFromRgb(color);\n  context.lineWidth = stroke.width;\n  context.stroke();\n}\nexport function drawPolygonMaskPath(engine, context, path, stroke, position) {\n  const defaultTransform = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1\n  };\n  context.setTransform(defaultTransform.a, defaultTransform.b, defaultTransform.c, defaultTransform.d, position.x, position.y);\n  const color = rangeColorToRgb(engine, stroke.color);\n  if (!color) {\n    return;\n  }\n  context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n  context.lineWidth = stroke.width;\n  context.stroke(path);\n  context.resetTransform();\n}\nexport function parsePaths(paths, scale, offset) {\n  const res = [],\n    defaultCount = 0;\n  for (const path of paths) {\n    const segments = path.element.pathSegList,\n      len = segments?.numberOfItems ?? defaultCount,\n      p = {\n        x: 0,\n        y: 0\n      };\n    for (let i = 0; i < len; i++) {\n      const segment = segments?.getItem(i),\n        svgPathSeg = window.SVGPathSeg;\n      switch (segment?.pathSegType) {\n        case svgPathSeg.PATHSEG_MOVETO_ABS:\n        case svgPathSeg.PATHSEG_LINETO_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n        case svgPathSeg.PATHSEG_ARC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n          {\n            const absSeg = segment;\n            p.x = absSeg.x;\n            p.y = absSeg.y;\n            break;\n          }\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n          p.x = segment.x;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n          p.y = segment.y;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_REL:\n        case svgPathSeg.PATHSEG_MOVETO_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n        case svgPathSeg.PATHSEG_ARC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n          {\n            const relSeg = segment;\n            p.x += relSeg.x;\n            p.y += relSeg.y;\n            break;\n          }\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n          p.x += segment.x;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n          p.y += segment.y;\n          break;\n        case svgPathSeg.PATHSEG_UNKNOWN:\n        case svgPathSeg.PATHSEG_CLOSEPATH:\n          continue;\n      }\n      res.push({\n        x: p.x * scale + offset.x,\n        y: p.y * scale + offset.y\n      });\n    }\n  }\n  return res;\n}\nexport function calcClosestPointOnSegment(s1, s2, pos) {\n  const {\n      dx: dx1,\n      dy: dy1\n    } = getDistances(pos, s1),\n    {\n      dx: dx2,\n      dy: dy2\n    } = getDistances(s2, s1),\n    t = (dx1 * dx2 + dy1 * dy2) / (dx2 ** squareExp + dy2 ** squareExp),\n    res = {\n      x: s1.x + dx2 * t,\n      y: s1.y + dy2 * t,\n      isOnSegment: t >= inSegmentRange.min && t <= inSegmentRange.max\n    };\n  if (t < inSegmentRange.min) {\n    res.x = s1.x;\n    res.y = s1.y;\n  } else if (t > inSegmentRange.max) {\n    res.x = s2.x;\n    res.y = s2.y;\n  }\n  return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n  const {\n      dx,\n      dy\n    } = getDistances(start, stop),\n    wallAngle = Math.atan2(dy, dx),\n    wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)),\n    d = double * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n  wallNormal.multTo(d);\n  velocity.subFrom(wallNormal);\n}","map":{"version":3,"names":["Vector","getDistances","getStyleFromRgb","rangeColorToRgb","squareExp","inSegmentRange","min","max","double","drawPolygonMask","engine","context","rawData","stroke","color","firstIndex","firstItem","beginPath","moveTo","x","y","item","lineTo","closePath","strokeStyle","lineWidth","width","drawPolygonMaskPath","path","position","defaultTransform","a","b","c","d","setTransform","opacity","resetTransform","parsePaths","paths","scale","offset","res","defaultCount","segments","element","pathSegList","len","numberOfItems","p","i","segment","getItem","svgPathSeg","window","SVGPathSeg","pathSegType","PATHSEG_MOVETO_ABS","PATHSEG_LINETO_ABS","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_ARC_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","absSeg","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_REL","PATHSEG_MOVETO_REL","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","relSeg","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_UNKNOWN","PATHSEG_CLOSEPATH","push","calcClosestPointOnSegment","s1","s2","pos","dx","dx1","dy","dy1","dx2","dy2","t","isOnSegment","segmentBounce","start","stop","velocity","wallAngle","Math","atan2","wallNormal","create","sin","cos","multTo","subFrom"],"sources":["/Users/nyanaung/repos/portfolio/node_modules/@tsparticles/plugin-polygon-mask/browser/utils.js"],"sourcesContent":["import { Vector, getDistances, getStyleFromRgb, rangeColorToRgb, } from \"@tsparticles/engine\";\nconst squareExp = 2, inSegmentRange = {\n    min: 0,\n    max: 1,\n}, double = 2;\nexport function drawPolygonMask(engine, context, rawData, stroke) {\n    const color = rangeColorToRgb(engine, stroke.color);\n    if (!color) {\n        return;\n    }\n    const firstIndex = 0, firstItem = rawData[firstIndex];\n    context.beginPath();\n    context.moveTo(firstItem.x, firstItem.y);\n    for (const item of rawData) {\n        context.lineTo(item.x, item.y);\n    }\n    context.closePath();\n    context.strokeStyle = getStyleFromRgb(color);\n    context.lineWidth = stroke.width;\n    context.stroke();\n}\nexport function drawPolygonMaskPath(engine, context, path, stroke, position) {\n    const defaultTransform = {\n        a: 1,\n        b: 0,\n        c: 0,\n        d: 1,\n    };\n    context.setTransform(defaultTransform.a, defaultTransform.b, defaultTransform.c, defaultTransform.d, position.x, position.y);\n    const color = rangeColorToRgb(engine, stroke.color);\n    if (!color) {\n        return;\n    }\n    context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n    context.lineWidth = stroke.width;\n    context.stroke(path);\n    context.resetTransform();\n}\nexport function parsePaths(paths, scale, offset) {\n    const res = [], defaultCount = 0;\n    for (const path of paths) {\n        const segments = path.element.pathSegList, len = segments?.numberOfItems ?? defaultCount, p = {\n            x: 0,\n            y: 0,\n        };\n        for (let i = 0; i < len; i++) {\n            const segment = segments?.getItem(i), svgPathSeg = window.SVGPathSeg;\n            switch (segment?.pathSegType) {\n                case svgPathSeg.PATHSEG_MOVETO_ABS:\n                case svgPathSeg.PATHSEG_LINETO_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                case svgPathSeg.PATHSEG_ARC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {\n                    const absSeg = segment;\n                    p.x = absSeg.x;\n                    p.y = absSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                    p.x = segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                    p.y = segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_REL:\n                case svgPathSeg.PATHSEG_MOVETO_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                case svgPathSeg.PATHSEG_ARC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {\n                    const relSeg = segment;\n                    p.x += relSeg.x;\n                    p.y += relSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                    p.x += segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                    p.y += segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_UNKNOWN:\n                case svgPathSeg.PATHSEG_CLOSEPATH:\n                    continue;\n            }\n            res.push({\n                x: p.x * scale + offset.x,\n                y: p.y * scale + offset.y,\n            });\n        }\n    }\n    return res;\n}\nexport function calcClosestPointOnSegment(s1, s2, pos) {\n    const { dx: dx1, dy: dy1 } = getDistances(pos, s1), { dx: dx2, dy: dy2 } = getDistances(s2, s1), t = (dx1 * dx2 + dy1 * dy2) / (dx2 ** squareExp + dy2 ** squareExp), res = {\n        x: s1.x + dx2 * t,\n        y: s1.y + dy2 * t,\n        isOnSegment: t >= inSegmentRange.min && t <= inSegmentRange.max,\n    };\n    if (t < inSegmentRange.min) {\n        res.x = s1.x;\n        res.y = s1.y;\n    }\n    else if (t > inSegmentRange.max) {\n        res.x = s2.x;\n        res.y = s2.y;\n    }\n    return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n    const { dx, dy } = getDistances(start, stop), wallAngle = Math.atan2(dy, dx), wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)), d = double * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n    wallNormal.multTo(d);\n    velocity.subFrom(wallNormal);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}