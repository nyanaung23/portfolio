{"ast":null,"code":"import { EmitterShapeBase } from \"@tsparticles/plugin-emitters\";\nimport { errorPrefix, percentDenominator } from \"@tsparticles/engine\";\nimport { generateRandomPointOnPathPerimeter, generateRandomPointWithinPath } from \"./utils.js\";\nconst half = 0.5;\nexport class EmittersPathShape extends EmitterShapeBase {\n  constructor(position, size, fill, options) {\n    super(position, size, fill, options);\n    const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n    if (!ctx) {\n      throw new Error(`${errorPrefix} No 2d context available`);\n    }\n    this.checkContext = ctx;\n    this.points = options.points;\n    const pathData = this.points,\n      path = new Path2D(),\n      offset = {\n        x: position.x - size.width * half,\n        y: position.y - size.height * half\n      };\n    for (const [index, point] of pathData.entries()) {\n      const coords = {\n        x: offset.x + point.x * size.width / percentDenominator,\n        y: offset.y + point.y * size.height / percentDenominator\n      };\n      if (!index) {\n        path.moveTo(coords.x, coords.y);\n      } else {\n        path.lineTo(coords.x, coords.y);\n      }\n    }\n    const firstIndex = 0,\n      firstPathData = pathData[firstIndex];\n    if (firstPathData) {\n      const coords = {\n        x: offset.x + firstPathData.x * size.width / percentDenominator,\n        y: offset.y + firstPathData.y * size.height / percentDenominator\n      };\n      path.lineTo(coords.x, coords.y);\n    }\n    this.path = path;\n  }\n  async init() {}\n  randomPosition() {\n    const ctx = this.checkContext,\n      position = this.position,\n      size = this.size,\n      fill = this.fill,\n      path = this.path,\n      res = fill ? generateRandomPointWithinPath(ctx, path, position, size) : generateRandomPointOnPathPerimeter(ctx, path, position, size);\n    return res ? {\n      position: res\n    } : null;\n  }\n  resize(position, size) {\n    super.resize(position, size);\n    const pathData = this.points,\n      path = new Path2D(),\n      offset = {\n        x: position.x - size.width * half,\n        y: position.y - size.height * half\n      };\n    for (const [index, point] of pathData.entries()) {\n      const coords = {\n        x: offset.x + point.x * size.width / percentDenominator,\n        y: offset.y + point.y * size.height / percentDenominator\n      };\n      if (!index) {\n        path.moveTo(coords.x, coords.y);\n      } else {\n        path.lineTo(coords.x, coords.y);\n      }\n    }\n    const firstIndex = 0,\n      firstPathData = pathData[firstIndex];\n    if (firstPathData) {\n      const coords = {\n        x: offset.x + firstPathData.x * size.width / percentDenominator,\n        y: offset.y + firstPathData.y * size.height / percentDenominator\n      };\n      path.lineTo(coords.x, coords.y);\n    }\n    this.path = path;\n  }\n}","map":{"version":3,"names":["EmitterShapeBase","errorPrefix","percentDenominator","generateRandomPointOnPathPerimeter","generateRandomPointWithinPath","half","EmittersPathShape","constructor","position","size","fill","options","ctx","document","createElement","getContext","Error","checkContext","points","pathData","path","Path2D","offset","x","width","y","height","index","point","entries","coords","moveTo","lineTo","firstIndex","firstPathData","init","randomPosition","res","resize"],"sources":["/Users/nyanaung/repos/portfolio/node_modules/@tsparticles/plugin-emitters-shape-path/browser/EmittersPathShape.js"],"sourcesContent":["import { EmitterShapeBase } from \"@tsparticles/plugin-emitters\";\nimport { errorPrefix, percentDenominator } from \"@tsparticles/engine\";\nimport { generateRandomPointOnPathPerimeter, generateRandomPointWithinPath } from \"./utils.js\";\nconst half = 0.5;\nexport class EmittersPathShape extends EmitterShapeBase {\n    constructor(position, size, fill, options) {\n        super(position, size, fill, options);\n        const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n        if (!ctx) {\n            throw new Error(`${errorPrefix} No 2d context available`);\n        }\n        this.checkContext = ctx;\n        this.points = options.points;\n        const pathData = this.points, path = new Path2D(), offset = {\n            x: position.x - size.width * half,\n            y: position.y - size.height * half,\n        };\n        for (const [index, point] of pathData.entries()) {\n            const coords = {\n                x: offset.x + (point.x * size.width) / percentDenominator,\n                y: offset.y + (point.y * size.height) / percentDenominator,\n            };\n            if (!index) {\n                path.moveTo(coords.x, coords.y);\n            }\n            else {\n                path.lineTo(coords.x, coords.y);\n            }\n        }\n        const firstIndex = 0, firstPathData = pathData[firstIndex];\n        if (firstPathData) {\n            const coords = {\n                x: offset.x + (firstPathData.x * size.width) / percentDenominator,\n                y: offset.y + (firstPathData.y * size.height) / percentDenominator,\n            };\n            path.lineTo(coords.x, coords.y);\n        }\n        this.path = path;\n    }\n    async init() {\n    }\n    randomPosition() {\n        const ctx = this.checkContext, position = this.position, size = this.size, fill = this.fill, path = this.path, res = fill\n            ? generateRandomPointWithinPath(ctx, path, position, size)\n            : generateRandomPointOnPathPerimeter(ctx, path, position, size);\n        return res ? { position: res } : null;\n    }\n    resize(position, size) {\n        super.resize(position, size);\n        const pathData = this.points, path = new Path2D(), offset = {\n            x: position.x - size.width * half,\n            y: position.y - size.height * half,\n        };\n        for (const [index, point] of pathData.entries()) {\n            const coords = {\n                x: offset.x + (point.x * size.width) / percentDenominator,\n                y: offset.y + (point.y * size.height) / percentDenominator,\n            };\n            if (!index) {\n                path.moveTo(coords.x, coords.y);\n            }\n            else {\n                path.lineTo(coords.x, coords.y);\n            }\n        }\n        const firstIndex = 0, firstPathData = pathData[firstIndex];\n        if (firstPathData) {\n            const coords = {\n                x: offset.x + (firstPathData.x * size.width) / percentDenominator,\n                y: offset.y + (firstPathData.y * size.height) / percentDenominator,\n            };\n            path.lineTo(coords.x, coords.y);\n        }\n        this.path = path;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}