{"ast":null,"code":"import { OutModeDirection, deepExtend, errorPrefix, getDistance, getDistances, getRandom, isArray, isString, itemFromArray, percentDenominator } from \"@tsparticles/engine\";\nimport { calcClosestPointOnSegment, drawPolygonMask, drawPolygonMaskPath, parsePaths, segmentBounce } from \"./utils.js\";\nimport { PolygonMaskInlineArrangement } from \"./Enums/PolygonMaskInlineArrangement.js\";\nimport { PolygonMaskType } from \"./Enums/PolygonMaskType.js\";\nconst noPolygonDataLoaded = `${errorPrefix} No polygon data loaded.`,\n  noPolygonFound = `${errorPrefix} No polygon found, you need to specify SVG url in config.`,\n  origin = {\n    x: 0,\n    y: 0\n  },\n  half = 0.5,\n  double = 2;\nexport class PolygonMaskInstance {\n  constructor(container, engine) {\n    this._checkInsidePolygon = position => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options?.enable || options.type === PolygonMaskType.none || options.type === PolygonMaskType.inline) {\n        return true;\n      }\n      if (!this.raw) {\n        throw new Error(noPolygonFound);\n      }\n      const canvasSize = container.canvas.size,\n        x = position?.x ?? getRandom() * canvasSize.width,\n        y = position?.y ?? getRandom() * canvasSize.height,\n        indexOffset = 1;\n      let inside = false;\n      for (let i = 0, j = this.raw.length - indexOffset; i < this.raw.length; j = i++) {\n        const pi = this.raw[i],\n          pj = this.raw[j],\n          intersect = pi.y > y !== pj.y > y && x < (pj.x - pi.x) * (y - pi.y) / (pj.y - pi.y) + pi.x;\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n      if (options.type === PolygonMaskType.inside) {\n        return inside;\n      } else {\n        return options.type === PolygonMaskType.outside ? !inside : false;\n      }\n    };\n    this._createPath2D = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options || !this.paths?.length) {\n        return;\n      }\n      for (const path of this.paths) {\n        const pathData = path.element?.getAttribute(\"d\");\n        if (pathData) {\n          const path2d = new Path2D(pathData),\n            matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix(),\n            finalPath = new Path2D(),\n            transform = matrix.scale(this._scale);\n          if (finalPath.addPath) {\n            finalPath.addPath(path2d, transform);\n            path.path2d = finalPath;\n          } else {\n            delete path.path2d;\n          }\n        } else {\n          delete path.path2d;\n        }\n        if (path.path2d ?? !this.raw) {\n          continue;\n        }\n        path.path2d = new Path2D();\n        const firstIndex = 0,\n          firstPoint = this.raw[firstIndex];\n        path.path2d.moveTo(firstPoint.x, firstPoint.y);\n        this.raw.forEach((pos, i) => {\n          if (i > firstIndex) {\n            path.path2d?.lineTo(pos.x, pos.y);\n          }\n        });\n        path.path2d.closePath();\n      }\n    };\n    this._downloadSvgPath = async (svgUrl, force) => {\n      const options = this._container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      const url = svgUrl ?? options.url,\n        forceDownload = force ?? false;\n      if (!url || this.paths !== undefined && !forceDownload) {\n        return this.raw;\n      }\n      const req = await fetch(url);\n      if (!req.ok) {\n        throw new Error(`${errorPrefix} occurred during polygon mask download`);\n      }\n      return this._parseSvgPath(await req.text(), force);\n    };\n    this._drawPoints = () => {\n      if (!this.raw) {\n        return;\n      }\n      for (const item of this.raw) {\n        void this._container.particles.addParticle({\n          x: item.x,\n          y: item.y\n        });\n      }\n    };\n    this._getEquidistantPointByIndex = index => {\n      const container = this._container,\n        options = container.actualOptions,\n        polygonMaskOptions = options.polygon;\n      if (!polygonMaskOptions) {\n        return;\n      }\n      if (!this.raw?.length || !this.paths?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      let offset = 0,\n        point;\n      const baseAccumulator = 0,\n        totalLength = this.paths.reduce((tot, path) => tot + path.length, baseAccumulator),\n        distance = totalLength / options.particles.number.value;\n      for (const path of this.paths) {\n        const pathDistance = distance * index - offset;\n        if (pathDistance <= path.length) {\n          point = path.element.getPointAtLength(pathDistance);\n          break;\n        } else {\n          offset += path.length;\n        }\n      }\n      const scale = this._scale;\n      return {\n        x: (point?.x ?? origin.x) * scale + (this.offset?.x ?? origin.x),\n        y: (point?.y ?? origin.y) * scale + (this.offset?.y ?? origin.y)\n      };\n    };\n    this._getPointByIndex = index => {\n      if (!this.raw?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const coords = this.raw[index % this.raw.length];\n      return {\n        x: coords.x,\n        y: coords.y\n      };\n    };\n    this._getRandomPoint = () => {\n      if (!this.raw?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const coords = itemFromArray(this.raw);\n      return {\n        x: coords.x,\n        y: coords.y\n      };\n    };\n    this._getRandomPointByLength = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      if (!this.raw?.length || !this.paths?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const path = itemFromArray(this.paths),\n        offset = 1,\n        distance = Math.floor(getRandom() * path.length) + offset,\n        point = path.element.getPointAtLength(distance),\n        scale = this._scale;\n      return {\n        x: point.x * scale + (this.offset?.x ?? origin.x),\n        y: point.y * scale + (this.offset?.y ?? origin.y)\n      };\n    };\n    this._initRawData = async force => {\n      const options = this._container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      if (options.url) {\n        this.raw = await this._downloadSvgPath(options.url, force);\n      } else if (options.data) {\n        const data = options.data;\n        let svg;\n        if (isString(data)) {\n          svg = data;\n        } else {\n          const getPath = p => `<path d=\"${p}\" />`,\n            path = isArray(data.path) ? data.path.map(getPath).join(\"\") : getPath(data.path);\n          const namespaces = 'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n          svg = `<svg ${namespaces} width=\"${data.size.width}\" height=\"${data.size.height}\">${path}</svg>`;\n        }\n        this.raw = this._parseSvgPath(svg, force);\n      }\n      this._createPath2D();\n      this._engine.dispatchEvent(\"polygonMaskLoaded\", {\n        container: this._container\n      });\n    };\n    this._parseSvgPath = (xml, force) => {\n      const forceDownload = force ?? false;\n      if (this.paths !== undefined && !forceDownload) {\n        return this.raw;\n      }\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      const parser = new DOMParser(),\n        doc = parser.parseFromString(xml, \"image/svg+xml\"),\n        firstIndex = 0,\n        svg = doc.getElementsByTagName(\"svg\")[firstIndex];\n      let svgPaths = svg.getElementsByTagName(\"path\");\n      if (!svgPaths.length) {\n        svgPaths = doc.getElementsByTagName(\"path\");\n      }\n      this.paths = [];\n      for (let i = 0; i < svgPaths.length; i++) {\n        const path = svgPaths.item(i);\n        if (path) {\n          this.paths.push({\n            element: path,\n            length: path.getTotalLength()\n          });\n        }\n      }\n      const scale = this._scale;\n      this.dimension.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\") * scale;\n      this.dimension.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\") * scale;\n      const position = options.position ?? {\n          x: 50,\n          y: 50\n        },\n        canvasSize = container.canvas.size;\n      this.offset = {\n        x: canvasSize.width * position.x / percentDenominator - this.dimension.width * half,\n        y: canvasSize.height * position.y / percentDenominator - this.dimension.height * half\n      };\n      return parsePaths(this.paths, scale, this.offset);\n    };\n    this._polygonBounce = (particle, delta, direction) => {\n      const options = this._container.actualOptions.polygon;\n      if (!this.raw || !options?.enable || direction !== OutModeDirection.top) {\n        return false;\n      }\n      if (options.type === PolygonMaskType.inside || options.type === PolygonMaskType.outside) {\n        let closest, dx, dy;\n        const pos = particle.getPosition(),\n          radius = particle.getRadius(),\n          offset = 1;\n        for (let i = 0, j = this.raw.length - offset; i < this.raw.length; j = i++) {\n          const pi = this.raw[i],\n            pj = this.raw[j];\n          closest = calcClosestPointOnSegment(pi, pj, pos);\n          const dist = getDistances(pos, closest);\n          [dx, dy] = [dist.dx, dist.dy];\n          if (dist.distance < radius) {\n            segmentBounce(pi, pj, particle.velocity);\n            return true;\n          }\n        }\n        if (closest && dx !== undefined && dy !== undefined && !this._checkInsidePolygon(pos)) {\n          const factor = {\n              x: 1,\n              y: 1\n            },\n            diameter = radius * double,\n            inverse = -1;\n          if (pos.x >= closest.x) {\n            factor.x = -1;\n          }\n          if (pos.y >= closest.y) {\n            factor.y = -1;\n          }\n          particle.position.x = closest.x + diameter * factor.x;\n          particle.position.y = closest.y + diameter * factor.y;\n          particle.velocity.mult(inverse);\n          return true;\n        }\n      } else if (options.type === PolygonMaskType.inline && particle.initialPosition) {\n        const dist = getDistance(particle.initialPosition, particle.getPosition()),\n          {\n            velocity\n          } = particle;\n        if (dist > this._moveRadius) {\n          velocity.x = velocity.y * half - velocity.x;\n          velocity.y = velocity.x * half - velocity.y;\n          return true;\n        }\n      }\n      return false;\n    };\n    this._randomPoint = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      let position;\n      if (options.type === PolygonMaskType.inline) {\n        switch (options.inline.arrangement) {\n          case PolygonMaskInlineArrangement.randomPoint:\n            position = this._getRandomPoint();\n            break;\n          case PolygonMaskInlineArrangement.randomLength:\n            position = this._getRandomPointByLength();\n            break;\n          case PolygonMaskInlineArrangement.equidistant:\n            position = this._getEquidistantPointByIndex(container.particles.count);\n            break;\n          case PolygonMaskInlineArrangement.onePerPoint:\n          case PolygonMaskInlineArrangement.perPoint:\n          default:\n            position = this._getPointByIndex(container.particles.count);\n        }\n      } else {\n        const canvasSize = container.canvas.size;\n        position = {\n          x: getRandom() * canvasSize.width,\n          y: getRandom() * canvasSize.height\n        };\n      }\n      if (this._checkInsidePolygon(position)) {\n        return position;\n      } else {\n        return this._randomPoint();\n      }\n    };\n    this._container = container;\n    this._engine = engine;\n    this.dimension = {\n      height: 0,\n      width: 0\n    };\n    this._moveRadius = 0;\n    this._scale = 1;\n  }\n  clickPositionValid(position) {\n    const options = this._container.actualOptions.polygon;\n    return !!options?.enable && options.type !== PolygonMaskType.none && options.type !== PolygonMaskType.inline && this._checkInsidePolygon(position);\n  }\n  draw(context) {\n    if (!this.paths?.length) {\n      return;\n    }\n    const options = this._container.actualOptions.polygon;\n    if (!options?.enable) {\n      return;\n    }\n    const polygonDraw = options.draw;\n    if (!polygonDraw.enable) {\n      return;\n    }\n    const rawData = this.raw;\n    for (const path of this.paths) {\n      const path2d = path.path2d;\n      if (!context) {\n        continue;\n      }\n      if (path2d && this.offset) {\n        drawPolygonMaskPath(this._engine, context, path2d, polygonDraw.stroke, this.offset);\n      } else if (rawData) {\n        drawPolygonMask(this._engine, context, rawData, polygonDraw.stroke);\n      }\n    }\n  }\n  async init() {\n    const container = this._container,\n      polygonMaskOptions = container.actualOptions.polygon,\n      pxRatio = container.retina.pixelRatio;\n    if (!polygonMaskOptions) {\n      return;\n    }\n    this._moveRadius = polygonMaskOptions.move.radius * pxRatio;\n    this._scale = polygonMaskOptions.scale * pxRatio;\n    if (polygonMaskOptions.enable) {\n      await this._initRawData();\n    }\n  }\n  particleBounce(particle, delta, direction) {\n    return this._polygonBounce(particle, delta, direction);\n  }\n  particlePosition(position) {\n    const options = this._container.actualOptions.polygon,\n      defaultLength = 0;\n    if (!(options?.enable && (this.raw?.length ?? defaultLength) > defaultLength)) {\n      return;\n    }\n    return deepExtend({}, position ? position : this._randomPoint());\n  }\n  particlesInitialization() {\n    const options = this._container.actualOptions.polygon;\n    if (options?.enable && options.type === PolygonMaskType.inline && (options.inline.arrangement === PolygonMaskInlineArrangement.onePerPoint || options.inline.arrangement === PolygonMaskInlineArrangement.perPoint)) {\n      this._drawPoints();\n      return true;\n    }\n    return false;\n  }\n  resize() {\n    const container = this._container,\n      options = container.actualOptions.polygon;\n    if (!(options?.enable && options.type !== PolygonMaskType.none)) {\n      return;\n    }\n    if (this.redrawTimeout) {\n      clearTimeout(this.redrawTimeout);\n    }\n    const timeout = 250;\n    this.redrawTimeout = setTimeout(() => {\n      void (async () => {\n        await this._initRawData(true);\n        await container.particles.redraw();\n      })();\n    }, timeout);\n  }\n  stop() {\n    delete this.raw;\n    delete this.paths;\n  }\n}","map":{"version":3,"names":["OutModeDirection","deepExtend","errorPrefix","getDistance","getDistances","getRandom","isArray","isString","itemFromArray","percentDenominator","calcClosestPointOnSegment","drawPolygonMask","drawPolygonMaskPath","parsePaths","segmentBounce","PolygonMaskInlineArrangement","PolygonMaskType","noPolygonDataLoaded","noPolygonFound","origin","x","y","half","double","PolygonMaskInstance","constructor","container","engine","_checkInsidePolygon","position","_container","options","actualOptions","polygon","enable","type","none","inline","raw","Error","canvasSize","canvas","size","width","height","indexOffset","inside","i","j","length","pi","pj","intersect","outside","_createPath2D","paths","path","pathData","element","getAttribute","path2d","Path2D","matrix","document","createElementNS","createSVGMatrix","finalPath","transform","scale","_scale","addPath","firstIndex","firstPoint","moveTo","forEach","pos","lineTo","closePath","_downloadSvgPath","svgUrl","force","url","forceDownload","undefined","req","fetch","ok","_parseSvgPath","text","_drawPoints","item","particles","addParticle","_getEquidistantPointByIndex","index","polygonMaskOptions","offset","point","baseAccumulator","totalLength","reduce","tot","distance","number","value","pathDistance","getPointAtLength","_getPointByIndex","coords","_getRandomPoint","_getRandomPointByLength","Math","floor","_initRawData","data","svg","getPath","p","map","join","namespaces","_engine","dispatchEvent","xml","parser","DOMParser","doc","parseFromString","getElementsByTagName","svgPaths","push","getTotalLength","dimension","parseFloat","_polygonBounce","particle","delta","direction","top","closest","dx","dy","getPosition","radius","getRadius","dist","velocity","factor","diameter","inverse","mult","initialPosition","_moveRadius","_randomPoint","arrangement","randomPoint","randomLength","equidistant","count","onePerPoint","perPoint","clickPositionValid","draw","context","polygonDraw","rawData","stroke","init","pxRatio","retina","pixelRatio","move","particleBounce","particlePosition","defaultLength","particlesInitialization","resize","redrawTimeout","clearTimeout","timeout","setTimeout","redraw","stop"],"sources":["/Users/nyanaung/repos/portfolio/node_modules/@tsparticles/plugin-polygon-mask/browser/PolygonMaskInstance.js"],"sourcesContent":["import { OutModeDirection, deepExtend, errorPrefix, getDistance, getDistances, getRandom, isArray, isString, itemFromArray, percentDenominator, } from \"@tsparticles/engine\";\nimport { calcClosestPointOnSegment, drawPolygonMask, drawPolygonMaskPath, parsePaths, segmentBounce } from \"./utils.js\";\nimport { PolygonMaskInlineArrangement } from \"./Enums/PolygonMaskInlineArrangement.js\";\nimport { PolygonMaskType } from \"./Enums/PolygonMaskType.js\";\nconst noPolygonDataLoaded = `${errorPrefix} No polygon data loaded.`, noPolygonFound = `${errorPrefix} No polygon found, you need to specify SVG url in config.`, origin = {\n    x: 0,\n    y: 0,\n}, half = 0.5, double = 2;\nexport class PolygonMaskInstance {\n    constructor(container, engine) {\n        this._checkInsidePolygon = position => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options?.enable || options.type === PolygonMaskType.none || options.type === PolygonMaskType.inline) {\n                return true;\n            }\n            if (!this.raw) {\n                throw new Error(noPolygonFound);\n            }\n            const canvasSize = container.canvas.size, x = position?.x ?? getRandom() * canvasSize.width, y = position?.y ?? getRandom() * canvasSize.height, indexOffset = 1;\n            let inside = false;\n            for (let i = 0, j = this.raw.length - indexOffset; i < this.raw.length; j = i++) {\n                const pi = this.raw[i], pj = this.raw[j], intersect = pi.y > y !== pj.y > y && x < ((pj.x - pi.x) * (y - pi.y)) / (pj.y - pi.y) + pi.x;\n                if (intersect) {\n                    inside = !inside;\n                }\n            }\n            if (options.type === PolygonMaskType.inside) {\n                return inside;\n            }\n            else {\n                return options.type === PolygonMaskType.outside ? !inside : false;\n            }\n        };\n        this._createPath2D = () => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options || !this.paths?.length) {\n                return;\n            }\n            for (const path of this.paths) {\n                const pathData = path.element?.getAttribute(\"d\");\n                if (pathData) {\n                    const path2d = new Path2D(pathData), matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix(), finalPath = new Path2D(), transform = matrix.scale(this._scale);\n                    if (finalPath.addPath) {\n                        finalPath.addPath(path2d, transform);\n                        path.path2d = finalPath;\n                    }\n                    else {\n                        delete path.path2d;\n                    }\n                }\n                else {\n                    delete path.path2d;\n                }\n                if (path.path2d ?? !this.raw) {\n                    continue;\n                }\n                path.path2d = new Path2D();\n                const firstIndex = 0, firstPoint = this.raw[firstIndex];\n                path.path2d.moveTo(firstPoint.x, firstPoint.y);\n                this.raw.forEach((pos, i) => {\n                    if (i > firstIndex) {\n                        path.path2d?.lineTo(pos.x, pos.y);\n                    }\n                });\n                path.path2d.closePath();\n            }\n        };\n        this._downloadSvgPath = async (svgUrl, force) => {\n            const options = this._container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            const url = svgUrl ?? options.url, forceDownload = force ?? false;\n            if (!url || (this.paths !== undefined && !forceDownload)) {\n                return this.raw;\n            }\n            const req = await fetch(url);\n            if (!req.ok) {\n                throw new Error(`${errorPrefix} occurred during polygon mask download`);\n            }\n            return this._parseSvgPath(await req.text(), force);\n        };\n        this._drawPoints = () => {\n            if (!this.raw) {\n                return;\n            }\n            for (const item of this.raw) {\n                void this._container.particles.addParticle({\n                    x: item.x,\n                    y: item.y,\n                });\n            }\n        };\n        this._getEquidistantPointByIndex = index => {\n            const container = this._container, options = container.actualOptions, polygonMaskOptions = options.polygon;\n            if (!polygonMaskOptions) {\n                return;\n            }\n            if (!this.raw?.length || !this.paths?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            let offset = 0, point;\n            const baseAccumulator = 0, totalLength = this.paths.reduce((tot, path) => tot + path.length, baseAccumulator), distance = totalLength / options.particles.number.value;\n            for (const path of this.paths) {\n                const pathDistance = distance * index - offset;\n                if (pathDistance <= path.length) {\n                    point = path.element.getPointAtLength(pathDistance);\n                    break;\n                }\n                else {\n                    offset += path.length;\n                }\n            }\n            const scale = this._scale;\n            return {\n                x: (point?.x ?? origin.x) * scale + (this.offset?.x ?? origin.x),\n                y: (point?.y ?? origin.y) * scale + (this.offset?.y ?? origin.y),\n            };\n        };\n        this._getPointByIndex = index => {\n            if (!this.raw?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            const coords = this.raw[index % this.raw.length];\n            return {\n                x: coords.x,\n                y: coords.y,\n            };\n        };\n        this._getRandomPoint = () => {\n            if (!this.raw?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            const coords = itemFromArray(this.raw);\n            return {\n                x: coords.x,\n                y: coords.y,\n            };\n        };\n        this._getRandomPointByLength = () => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            if (!this.raw?.length || !this.paths?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            const path = itemFromArray(this.paths), offset = 1, distance = Math.floor(getRandom() * path.length) + offset, point = path.element.getPointAtLength(distance), scale = this._scale;\n            return {\n                x: point.x * scale + (this.offset?.x ?? origin.x),\n                y: point.y * scale + (this.offset?.y ?? origin.y),\n            };\n        };\n        this._initRawData = async (force) => {\n            const options = this._container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            if (options.url) {\n                this.raw = await this._downloadSvgPath(options.url, force);\n            }\n            else if (options.data) {\n                const data = options.data;\n                let svg;\n                if (isString(data)) {\n                    svg = data;\n                }\n                else {\n                    const getPath = (p) => `<path d=\"${p}\" />`, path = isArray(data.path) ? data.path.map(getPath).join(\"\") : getPath(data.path);\n                    const namespaces = 'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n                    svg = `<svg ${namespaces} width=\"${data.size.width}\" height=\"${data.size.height}\">${path}</svg>`;\n                }\n                this.raw = this._parseSvgPath(svg, force);\n            }\n            this._createPath2D();\n            this._engine.dispatchEvent(\"polygonMaskLoaded\", {\n                container: this._container,\n            });\n        };\n        this._parseSvgPath = (xml, force) => {\n            const forceDownload = force ?? false;\n            if (this.paths !== undefined && !forceDownload) {\n                return this.raw;\n            }\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            const parser = new DOMParser(), doc = parser.parseFromString(xml, \"image/svg+xml\"), firstIndex = 0, svg = doc.getElementsByTagName(\"svg\")[firstIndex];\n            let svgPaths = svg.getElementsByTagName(\"path\");\n            if (!svgPaths.length) {\n                svgPaths = doc.getElementsByTagName(\"path\");\n            }\n            this.paths = [];\n            for (let i = 0; i < svgPaths.length; i++) {\n                const path = svgPaths.item(i);\n                if (path) {\n                    this.paths.push({\n                        element: path,\n                        length: path.getTotalLength(),\n                    });\n                }\n            }\n            const scale = this._scale;\n            this.dimension.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\") * scale;\n            this.dimension.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\") * scale;\n            const position = options.position ?? {\n                x: 50,\n                y: 50,\n            }, canvasSize = container.canvas.size;\n            this.offset = {\n                x: (canvasSize.width * position.x) / percentDenominator - this.dimension.width * half,\n                y: (canvasSize.height * position.y) / percentDenominator - this.dimension.height * half,\n            };\n            return parsePaths(this.paths, scale, this.offset);\n        };\n        this._polygonBounce = (particle, delta, direction) => {\n            const options = this._container.actualOptions.polygon;\n            if (!this.raw || !options?.enable || direction !== OutModeDirection.top) {\n                return false;\n            }\n            if (options.type === PolygonMaskType.inside || options.type === PolygonMaskType.outside) {\n                let closest, dx, dy;\n                const pos = particle.getPosition(), radius = particle.getRadius(), offset = 1;\n                for (let i = 0, j = this.raw.length - offset; i < this.raw.length; j = i++) {\n                    const pi = this.raw[i], pj = this.raw[j];\n                    closest = calcClosestPointOnSegment(pi, pj, pos);\n                    const dist = getDistances(pos, closest);\n                    [dx, dy] = [dist.dx, dist.dy];\n                    if (dist.distance < radius) {\n                        segmentBounce(pi, pj, particle.velocity);\n                        return true;\n                    }\n                }\n                if (closest && dx !== undefined && dy !== undefined && !this._checkInsidePolygon(pos)) {\n                    const factor = { x: 1, y: 1 }, diameter = radius * double, inverse = -1;\n                    if (pos.x >= closest.x) {\n                        factor.x = -1;\n                    }\n                    if (pos.y >= closest.y) {\n                        factor.y = -1;\n                    }\n                    particle.position.x = closest.x + diameter * factor.x;\n                    particle.position.y = closest.y + diameter * factor.y;\n                    particle.velocity.mult(inverse);\n                    return true;\n                }\n            }\n            else if (options.type === PolygonMaskType.inline && particle.initialPosition) {\n                const dist = getDistance(particle.initialPosition, particle.getPosition()), { velocity } = particle;\n                if (dist > this._moveRadius) {\n                    velocity.x = velocity.y * half - velocity.x;\n                    velocity.y = velocity.x * half - velocity.y;\n                    return true;\n                }\n            }\n            return false;\n        };\n        this._randomPoint = () => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            let position;\n            if (options.type === PolygonMaskType.inline) {\n                switch (options.inline.arrangement) {\n                    case PolygonMaskInlineArrangement.randomPoint:\n                        position = this._getRandomPoint();\n                        break;\n                    case PolygonMaskInlineArrangement.randomLength:\n                        position = this._getRandomPointByLength();\n                        break;\n                    case PolygonMaskInlineArrangement.equidistant:\n                        position = this._getEquidistantPointByIndex(container.particles.count);\n                        break;\n                    case PolygonMaskInlineArrangement.onePerPoint:\n                    case PolygonMaskInlineArrangement.perPoint:\n                    default:\n                        position = this._getPointByIndex(container.particles.count);\n                }\n            }\n            else {\n                const canvasSize = container.canvas.size;\n                position = {\n                    x: getRandom() * canvasSize.width,\n                    y: getRandom() * canvasSize.height,\n                };\n            }\n            if (this._checkInsidePolygon(position)) {\n                return position;\n            }\n            else {\n                return this._randomPoint();\n            }\n        };\n        this._container = container;\n        this._engine = engine;\n        this.dimension = {\n            height: 0,\n            width: 0,\n        };\n        this._moveRadius = 0;\n        this._scale = 1;\n    }\n    clickPositionValid(position) {\n        const options = this._container.actualOptions.polygon;\n        return (!!options?.enable &&\n            options.type !== PolygonMaskType.none &&\n            options.type !== PolygonMaskType.inline &&\n            this._checkInsidePolygon(position));\n    }\n    draw(context) {\n        if (!this.paths?.length) {\n            return;\n        }\n        const options = this._container.actualOptions.polygon;\n        if (!options?.enable) {\n            return;\n        }\n        const polygonDraw = options.draw;\n        if (!polygonDraw.enable) {\n            return;\n        }\n        const rawData = this.raw;\n        for (const path of this.paths) {\n            const path2d = path.path2d;\n            if (!context) {\n                continue;\n            }\n            if (path2d && this.offset) {\n                drawPolygonMaskPath(this._engine, context, path2d, polygonDraw.stroke, this.offset);\n            }\n            else if (rawData) {\n                drawPolygonMask(this._engine, context, rawData, polygonDraw.stroke);\n            }\n        }\n    }\n    async init() {\n        const container = this._container, polygonMaskOptions = container.actualOptions.polygon, pxRatio = container.retina.pixelRatio;\n        if (!polygonMaskOptions) {\n            return;\n        }\n        this._moveRadius = polygonMaskOptions.move.radius * pxRatio;\n        this._scale = polygonMaskOptions.scale * pxRatio;\n        if (polygonMaskOptions.enable) {\n            await this._initRawData();\n        }\n    }\n    particleBounce(particle, delta, direction) {\n        return this._polygonBounce(particle, delta, direction);\n    }\n    particlePosition(position) {\n        const options = this._container.actualOptions.polygon, defaultLength = 0;\n        if (!(options?.enable && (this.raw?.length ?? defaultLength) > defaultLength)) {\n            return;\n        }\n        return deepExtend({}, position ? position : this._randomPoint());\n    }\n    particlesInitialization() {\n        const options = this._container.actualOptions.polygon;\n        if (options?.enable &&\n            options.type === PolygonMaskType.inline &&\n            (options.inline.arrangement === PolygonMaskInlineArrangement.onePerPoint ||\n                options.inline.arrangement === PolygonMaskInlineArrangement.perPoint)) {\n            this._drawPoints();\n            return true;\n        }\n        return false;\n    }\n    resize() {\n        const container = this._container, options = container.actualOptions.polygon;\n        if (!(options?.enable && options.type !== PolygonMaskType.none)) {\n            return;\n        }\n        if (this.redrawTimeout) {\n            clearTimeout(this.redrawTimeout);\n        }\n        const timeout = 250;\n        this.redrawTimeout = setTimeout(() => {\n            void (async () => {\n                await this._initRawData(true);\n                await container.particles.redraw();\n            })();\n        }, timeout);\n    }\n    stop() {\n        delete this.raw;\n        delete this.paths;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}